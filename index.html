<!doctype html>
<html lang="ht">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>TF-Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#000000; --panel:#000000; --text:#e6eefb; --muted:#9aa6bf;
  --card:#0b0b0b; --accent:#0b81ff; --header-h:56px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Roboto,system-ui,Arial,sans-serif;-webkit-font-smoothing:antialiased}
header{position:fixed;left:0;right:0;top:0;height:var(--header-h);display:flex;align-items:center;justify-content:center;background:var(--panel);z-index:1000;border-bottom:1px solid rgba(255,255,255,0.03)}
.app-title{font-weight:700;font-size:18px}
main{position:fixed;left:0;right:0;top:var(--header-h);bottom:0;overflow:auto;padding:12px;display:flex;flex-direction:column;gap:12px}
.search{padding:6px 0}
.search-box{display:flex;align-items:center;gap:8px;background:var(--card);padding:10px;border-radius:999px;border:1px solid rgba(255,255,255,0.03)}
.search-box input{flex:1;background:transparent;border:0;outline:none;color:var(--text);font-size:15px}
.search-btn{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
.container { display:flex; flex:1; gap:12px; align-items:stretch; }
.list{width:360px; max-width:42%; background:var(--card); border-radius:14px; padding:12px; overflow:auto}
.chat-area{flex:1; background:var(--card); border-radius:14px; padding:0; display:flex; flex-direction:column; overflow:hidden}
.contact{display:flex;gap:12px;align-items:center;padding:12px;border-radius:12px;cursor:pointer}
.contact:hover{background:rgba(255,255,255,0.02)}
.avatar{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));display:inline-flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;color:var(--text);flex-shrink:0}
.meta{flex:1;min-width:0}
.meta-top{display:flex;justify-content:space-between;align-items:flex-start}
.name{font-weight:600;font-size:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.time{font-size:12px;color:var(--muted)}
.meta-bottom{display:flex;justify-content:space-between;margin-top:6px;align-items:center}
.snippet{font-size:13px;color:var(--muted);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.badge{background:var(--accent);color:white;padding:4px 8px;border-radius:999px;font-weight:600;font-size:13px}
.messages{padding:16px;flex:1;overflow:auto;display:flex;flex-direction:column;gap:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
.msg{max-width:72%;padding:10px;border-radius:12px;margin-bottom:4px}
.msg.bot{background:#121212;color:var(--text);align-self:flex-start}
.msg.user{background:linear-gradient(180deg,var(--accent),#0563c9);color:white;align-self:flex-end}
.msg .checks{font-size:11px;margin-left:8px;opacity:0.95}
.header-chat{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid rgba(255,255,255,0.03)}
.header-chat .avatar-lg{width:48px;height:48px;border-radius:12px;background:#cbd5e1;display:flex;align-items:center;justify-content:center;font-weight:700}
.header-chat .info{flex:1}
.header-chat .info .name{font-weight:800}
.chat-composer{padding:12px;border-top:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:center;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.06))}
.composer-input{flex:1;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);background:var(--card);color:var(--text);outline:none}
.send-btn{background:transparent;border:0;padding:8px;border-radius:10px;cursor:pointer;color:var(--accent)}
.muted{text-align:center;color:var(--muted);padding:20px}
.bottom-right { position: fixed; right: 16px; bottom: 16px; z-index: 1100; display:flex; gap:8px; align-items:center; }
.ws-indicator{font-size:12px;color:var(--muted);margin-right:8px}
@media (max-width:900px){ .container{flex-direction:column} .list{width:100%;max-width:none} .chat-area{width:100%;} }

/* settings/profile */
.settings-panel{width:420px;background:#fff;border-radius:12px;padding:18px;box-shadow:0 10px 30px rgba(11,18,32,0.2);color:#0b1220}
.settings-label{font-size:13px;color:#374151}
.banner { position: fixed; left: 50%; transform: translateX(-50%); top: calc(var(--header-h) + 8px); z-index:1300; background:#fffbeb; color:#92400e; border:1px solid #f59e0b; padding:10px 14px;border-radius:10px; display:none; }
.profile-modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1400; background:rgba(0,0,0,0.6); }
.profile-card { width:320px; background:#fff; color:#0b1220; padding:18px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.3); }
.profile-row{display:flex;align-items:center;gap:12px;margin-bottom:10px}
.profile-avatar{width:64px;height:64px;border-radius:12px;background:#cbd5e1;display:flex;align-items:center;justify-content:center;font-weight:700}
.file-input { display:flex; gap:8px; align-items:center; margin-top:8px; }
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <header><div class="app-title">TF-Chat</div></header>

  <div class="banner" id="pwBanner">Tanpri mete yon modpas pou sekirize sesyon ou (opsyonèl).</div>

  <main>
    <div class="search">
      <div class="search-box" role="search">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6"/><circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.6"/></svg>
        <input id="searchInput" placeholder="Recherche (TFID ou 7 chif)" aria-label="Recherche" />
        <button id="searchBtn" class="search-btn">Rechercher</button>
      </div>
    </div>

    <div class="container">
      <div class="list" id="contactsList" aria-live="polite"></div>

      <div class="chat-area" id="chatArea">
        <div class="header-chat" id="headerChat">
          <div class="avatar-lg" id="chatAvatar">—</div>
          <div class="info">
            <div class="name" id="chatName">Aucun contact sélectionné</div>
            <div class="small" id="chatSub">Sélectionne un contact</div>
          </div>
          <div class="small"><span id="wsStatus">WS: —</span></div>
        </div>

        <div class="messages" id="messagesContainer"><div class="muted">Sélectionne un contact pour commencer</div></div>

        <div class="chat-composer" id="composer" style="display:none">
          <input id="composerInput" class="composer-input" placeholder="Écrire un message..." />
          <button id="sendBtn" class="send-btn">Envoyer</button>
        </div>
      </div>
    </div>
  </main>

  <!-- profile modal -->
  <div class="profile-modal" id="profileModal">
    <div class="profile-card">
      <div class="profile-row">
        <div class="profile-avatar" id="profileAvatar">U</div>
        <div>
          <div id="profileName" style="font-weight:800">Utilisateur</div>
          <div id="profileTfid" class="small">TF-0000000</div>
        </div>
      </div>

      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="addContactBtn" style="padding:8px 12px;border-radius:8px;border:1px solid #e6edf3;background:white;cursor:pointer">Ajouter</button>
        <button id="blockBtn" style="padding:8px 12px;border-radius:8px;background:#ef4444;color:white;border:none;cursor:pointer">Bloquer</button>
        <button id="closeProfileBtn" style="padding:8px 12px;border-radius:8px;border:1px solid #e6edf3;background:white;cursor:pointer">Fermer</button>
      </div>
    </div>
  </div>

  <!-- settings modal -->
  <div id="settingsModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:1200;align-items:center;justify-content:center;display:flex;">
    <div class="settings-panel" role="dialog" aria-modal="true">
      <h3 style="margin:0 0 12px 0">Paramètres — Identité</h3>

      <div style="margin-bottom:8px">
        <label class="settings-label">Pseudo affiché</label>
        <input id="profileNameInput" style="width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef3;margin-top:6px" />
      </div>

      <div style="margin-bottom:12px">
        <label class="settings-label">TFID (7 chif) — ex: 0204143</label>
        <input id="profileTfidInput" style="width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef3;margin-top:6px" />
        <div style="font-size:12px;color:#6b7280;margin-top:6px">Sere TFID tankou TF-XXXXXXX. Sistèm lan konvèti pou TF-17-chif otomatikman.</div>
      </div>

      <div style="margin-bottom:12px">
        <label class="settings-label">Mot de passe (créer / changer)</label>
        <input id="profilePwInput" type="password" placeholder="Nouveau mot de passe" style="width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef3;margin-top:6px" />
        <div style="font-size:12px;color:#6b7280;margin-top:6px">Le mot de passe est haché côté client et stocké localement.</div>
      </div>

      <div style="margin-bottom:10px">
        <label class="settings-label">Photo de profil (jpg/png seulement)</label>
        <div class="file-input">
          <input id="profileFile" type="file" accept="image/*" />
          <button id="uploadBtn" style="padding:8px 12px;border-radius:8px;background:#007aff;color:white;border:none;cursor:pointer">Uploader</button>
        </div>
        <div class="small" style="margin-top:6px">Après upload, la photo sera poussée comme update profile à tous vos contacts.</div>
      </div>

      <div style="display:flex;justify-content:flex-end;gap:8px">
        <button id="settingsCancel" style="padding:8px 12px;border-radius:8px;border:1px solid #e6edf3;background:white;cursor:pointer">Annuler</button>
        <button id="profileSave" style="padding:8px 12px;border-radius:8px;background:#007aff;color:white;border:none;cursor:pointer">Sove</button>
      </div>
    </div>
  </div>

<script>
/* CONFIG */
const API_BASE = 'https://tf-sove.onrender.com';
const FRONTEND_NAME = 'site1';
const ADMIN_API_TOKEN = 'tfstream_45dd9c02d4e34f18a42d';
const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + "tf-sove.onrender.com/ws";

/* image upload base (external service you specified) */
const IMAGE_UPLOAD_BASE = 'https://tf-stream-url.onrender.com/upload';

/* HELPERS */
function normalizeInputToDigits(inp){ if(!inp) return null; const s=String(inp).trim().toUpperCase(); const digits=s.replace(/[^0-9]/g,''); return digits||null; }
function to17(shortOrDigits){ if(!shortOrDigits) return null; const ds=String(shortOrDigits).replace(/[^0-9]/g,''); if(ds.length>17) return ds.slice(-17); return ds.padStart(17,'0'); }
function formatTFShort(digitsString){ if(!digitsString) return ''; const s=String(digitsString).replace(/[^0-9]/g,''); const last7 = s.slice(-7); return 'TF-'+ last7.padStart(7,'0'); }
function nowISO(){ return (new Date()).toISOString(); }
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function makeCid(){ return String(Date.now()) + '-' + Math.floor(Math.random()*100000).toString(16); }
function initials(name){ if(!name) return 'U'; return name.split(' ').map(p=>p[0]).slice(0,2).join('').toUpperCase(); }

/* simple hash pw (WebCrypto) */
async function hashPasswordHex(pw){
  const enc = new TextEncoder();
  const data = enc.encode(String(pw));
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}

/* STATE */
let me = {
  short: localStorage.getItem('tfchat.me.short') || null,
  tf17: localStorage.getItem('tfchat.me.17') || null,
  name: localStorage.getItem('tfchat.me.name') || 'Utilisateur',
  avatarDataUrl: localStorage.getItem('tfchat.me.avatar') || null
};
let contacts = JSON.parse(localStorage.getItem('tfchat.contacts') || '[]');
let ws = null;
let reconnectTimer = null;
let currentPartner = null;
const conversationCache = {};

/* DOM */
const contactsListEl = document.getElementById('contactsList');
const messagesContainer = document.getElementById('messagesContainer');
const chatNameEl = document.getElementById('chatName');
const chatSubEl = document.getElementById('chatSub');
const chatAvatar = document.getElementById('chatAvatar');
const composer = document.getElementById('composer');
const composerInput = document.getElementById('composerInput');
const sendBtn = document.getElementById('sendBtn');
const wsStatus = document.getElementById('wsStatus');
const profileModal = document.getElementById('profileModal');
const profileAvatar = document.getElementById('profileAvatar');
const profileName = document.getElementById('profileName');
const profileTfid = document.getElementById('profileTfid');
const addContactBtn = document.getElementById('addContactBtn');
const blockBtn = document.getElementById('blockBtn');
const closeProfileBtn = document.getElementById('closeProfileBtn');
const pwBanner = document.getElementById('pwBanner');

/* settings UI refs */
const settingsModal = document.getElementById('settingsModal');
const profileNameInput = document.getElementById('profileNameInput');
const profileTfidInput = document.getElementById('profileTfidInput');
const profilePwInput = document.getElementById('profilePwInput');
const profileFile = document.getElementById('profileFile');
const uploadBtn = document.getElementById('uploadBtn');
const profileSave = document.getElementById('profileSave');
const settingsCancel = document.getElementById('settingsCancel');

/* storage helpers */
function saveState(){ localStorage.setItem('tfchat.me.short', me.short || ''); localStorage.setItem('tfchat.me.17', me.tf17 || ''); localStorage.setItem('tfchat.me.name', me.name || ''); if(me.avatarDataUrl) localStorage.setItem('tfchat.me.avatar', me.avatarDataUrl); localStorage.setItem('tfchat.contacts', JSON.stringify(contacts || [])); }
function pwKeyForTf(tf17){ return `tfchat.pw.${tf17}`; }
function hasPasswordFor(tf17){ return !!localStorage.getItem(pwKeyForTf(tf17)); }
function storePasswordHash(tf17, hex){ localStorage.setItem(pwKeyForTf(tf17), hex); }
function getPasswordHash(tf17){ return localStorage.getItem(pwKeyForTf(tf17)); }

/* network helpers */
async function callJSON(url, opts = {}) {
  opts = Object.assign({}, opts);
  opts.headers = Object.assign({}, opts.headers || {}, { 'Accept': 'application/json' });
  try {
    const r = await fetch(url, opts);
    const text = await r.text();
    let json = null;
    try{ json = JSON.parse(text); }catch(e){}
    return { ok: r.ok, status: r.status, json, text };
  } catch (err) {
    return { ok: false, error: err.message };
  }
}

/* API helpers (list/add + block endpoints that backend must implement for full effect) */
async function apiList(tf17){ const url = `${API_BASE}/api/list?tfid=${encodeURIComponent(tf17)}&name=${encodeURIComponent(FRONTEND_NAME)}`; const r = await callJSON(url); if(!r.ok) throw new Error(r.json?.error || r.text || `HTTP ${r.status}`); return r.json.rows || []; }
async function apiAdd(recipient17, contentObj){ const body = { tfid: recipient17, name: FRONTEND_NAME, content: JSON.stringify(contentObj), source_url: location.origin }; const url = `${API_BASE}/api/add`; const r = await callJSON(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) }); if(!r.ok){ const errMsg = r.json?.error || r.text || `HTTP ${r.status}`; throw new Error(errMsg); } return r.json; }

/* block endpoints (frontend uses these; backend should implement them) */
async function apiBlock(by17, target17){
  try {
    const r = await callJSON(`${API_BASE}/api/block`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ by: by17, tfid: target17 })});
    return r.ok ? (r.json || { ok:true }) : { ok:false, error: r.json?.error || r.text };
  } catch(e){ return { ok:false, error: e.message }; }
}
async function apiUnblock(by17, target17){
  try {
    const r = await callJSON(`${API_BASE}/api/unblock`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ by: by17, tfid: target17 })});
    return r.ok ? (r.json || { ok:true }) : { ok:false, error: r.json?.error || r.text };
  } catch(e){ return { ok:false, error: e.message }; }
}
async function apiCheckBlocked(me17, other17){
  try {
    const r = await callJSON(`${API_BASE}/api/blocked?tfid=${encodeURIComponent(me17)}&other=${encodeURIComponent(other17)}`);
    if(r.ok && r.json) return r.json;
    return null;
  } catch(e){ return null; }
}

/* conversation caching and render (similar as before) */
function convKey(a,b){ return `${a}|${b}`; }
function messageUniqueKey(m){ if(m.cid) return "cid:"+m.cid; if(m.id) return "id:"+m.id; return "temp:"+ (m._tempKey || (m._tempKey = Math.random().toString(36).slice(2))); }
function parseDatePrefer(isoOrDb, parsedTime){ const t1 = parsedTime ? Date.parse(parsedTime) : NaN; if(!isNaN(t1)) return t1; const t2 = Date.parse(isoOrDb || ""); return isNaN(t2) ? 0 : t2; }
function compareMessagesAsc(a,b){ const ta = parseDatePrefer(a._db_created_at, a.parsed_time); const tb = parseDatePrefer(b._db_created_at, b.parsed_time); if(ta !== tb) return ta - tb; if(a.id && b.id && a.id !== b.id) return Number(a.id) - Number(b.id); if(a.cid && b.cid && a.cid !== b.cid) return a.cid < b.cid ? -1 : 1; return 0; }
function addOrUpdateMessageToCache(me17, other17, msg){ const key = convKey(me17, other17); if(!conversationCache[key]) conversationCache[key] = []; const list = conversationCache[key]; const findIndex = msg.cid ? list.findIndex(x => x.cid && x.cid === msg.cid) : (msg.id ? list.findIndex(x => x.id && String(x.id) === String(msg.id)) : -1); if(findIndex !== -1){ list[findIndex] = Object.assign({}, list[findIndex], msg); } else { list.push(msg); } list.sort(compareMessagesAsc); }

async function loadConversation(me17, other17){
  const key = convKey(me17, other17);
  conversationCache[key] = conversationCache[key] || [];
  const seen = new Set();
  function pushRow(r, expectedFrom){
    let parsed = null;
    try { parsed = JSON.parse(r.content); } catch(e){ parsed = null; }
    const parsedFrom = parsed && parsed.from ? parsed.from : null;
    const parsedText = parsed && (parsed.text || parsed.message) ? (parsed.text || parsed.message) : (r.content || "");
    const parsedTime = parsed && parsed.time ? parsed.time : null;
    const parsedCid = parsed && parsed.cid ? parsed.cid : null;
    if(!parsedFrom || parsedFrom !== expectedFrom) return;
    const m = { id: r.id || null, cid: parsedCid || null, from: parsedFrom, text: parsedText, parsed_time: parsedTime || null, _db_created_at: r.created_at || null, created_at: parsedTime || r.created_at || nowISO() };
    const keyu = messageUniqueKey(m);
    if(seen.has(keyu)) return;
    seen.add(keyu);
    addOrUpdateMessageToCache(me17, other17, m);
  }
  try { const outRows = await apiList(other17); for(const r of outRows) pushRow(r, me17); } catch(e){ console.warn("LIST outgoing failed", e); }
  try { const inRows = await apiList(me17); for(const r of inRows) pushRow(r, other17); } catch(e){ console.warn("LIST incoming failed", e); }
  renderConversation(me17, other17);
}

function renderConversation(me17, other17){
  const key = convKey(me17, other17);
  const arr = conversationCache[key] ? [...conversationCache[key]] : [];
  messagesContainer.innerHTML = '';
  if(arr.length === 0){ messagesContainer.innerHTML = `<div class="muted">Pas encore de messages entre vous.</div>`; } else {
    arr.sort(compareMessagesAsc);
    for(const m of arr){
      // filter out messages from blocked users: if me blocked other show nothing; (we also ask server to filter)
      const c = contacts.find(x=>x.tf17===other17);
      if(c && c.blocked && m.from === other17){
        // skip incoming messages from user you blocked
        continue;
      }
      const d = document.createElement('div');
      d.className = 'msg ' + (m.from === me17 ? 'user' : 'bot');
      const ts = m.created_at ? (new Date(m.created_at)).toLocaleString() : '';
      let checksHtml = '';
      if(m.from === me17){
        if(m.id) checksHtml = '<span class="checks">✓✓</span>';
        else checksHtml = '<span class="checks">✓</span>';
      }
      d.innerHTML = `<div>${escapeHtml(m.text)}</div><div style="font-size:11px;color:var(--muted);margin-top:6px">${formatTFShort(m.from||'')} • ${ts} ${checksHtml}</div>`;
      messagesContainer.appendChild(d);
    }
  }
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

/* Contacts rendering */
function renderContacts(){
  contactsListEl.innerHTML = '';
  if(contacts.length===0){ contactsListEl.innerHTML = `<div class="muted">Aucun contact. Rechercher un TFID.</div>`; return; }
  for(const c of contacts){
    const el = document.createElement('div');
    el.className = 'contact';
    el.dataset.tf17 = c.tf17;
    const blockedBadge = c.blocked ? ' <span style="color:#ffdcdc;font-weight:700">(Bloqué)</span>' : '';
    el.innerHTML = `<div class="avatar">${c.logo?'<img src="'+c.logo+'" style="width:100%;height:100%;border-radius:50%"/>':escapeHtml((c.name||formatTFShort(c.tf17)).slice(0,2))}</div>
      <div class="meta">
        <div class="meta-top"><div class="name">${escapeHtml(c.name||formatTFShort(c.tf17))}${blockedBadge}</div><div class="time">${c.lastTs? timeAgo(c.lastTs):''}</div></div>
        <div class="meta-bottom"><div class="snippet">${escapeHtml(c.lastMsg||'')}</div><div>${c.unread?'<span class="badge">'+c.unread+'</span>':''}</div></div>
      </div>`;
    el.addEventListener('click', ()=> openChat(c.tf17, c));
    // right-click or long-press -> open profile modal
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openProfileModal(c.tf17); });
    contactsListEl.appendChild(el);
  }
}
function timeAgo(ts){ if(!ts) return ''; const diff=Math.floor((Date.now()-ts)/1000); if(diff<60) return diff+'s'; if(diff<3600) return Math.floor(diff/60)+'m'; if(diff<86400) return Math.floor(diff/3600)+'h'; return new Date(ts).toLocaleDateString(); }

/* ensure contact in list */
function ensureContactInList(tf17, name){
  let c = contacts.find(x=>x.tf17===tf17);
  if(!c){ c = { tf17, name: name||formatTFShort(tf17), lastMsg:'', lastTs: Date.now(), unread:0, blocked:false, logo:null }; contacts.unshift(c); saveState(); renderContacts(); }
  return c;
}

/* PROFILE modal functions */
let profileCurrent = null;
function openProfileModal(tf17){
  profileCurrent = tf17;
  const c = contacts.find(x=>x.tf17===tf17) || { tf17, name: formatTFShort(tf17), blocked:false };
  profileAvatar.textContent = initials(c.name||c.tf17);
  profileName.textContent = c.name || formatTFShort(tf17);
  profileTfid.textContent = c.tf17;
  blockBtn.textContent = c.blocked ? 'Débloquer' : 'Bloquer';
  profileModal.style.display = 'flex';
}
addContactBtn.addEventListener('click', ()=>{
  if(!profileCurrent) return;
  const c = ensureContactInList(profileCurrent, null);
  alert('Contact ajouté : ' + (c.name||c.tf17));
  profileModal.style.display = 'none';
});
blockBtn.addEventListener('click', async ()=>{
  if(!profileCurrent || !me.tf17) { alert('No selection'); return; }
  const c = ensureContactInList(profileCurrent, null);
  if(!c.blocked){
    // block API
    const resp = await apiBlock(me.tf17, profileCurrent);
    if(resp.ok!==false){ c.blocked = true; saveState(); renderContacts(); openProfileModal(profileCurrent); alert('Utilisateur bloqué'); }
    else { // fallback local
      c.blocked = true; saveState(); renderContacts(); openProfileModal(profileCurrent); alert('Bloqué local (backend non disponible)'); }
  } else {
    const resp = await apiUnblock(me.tf17, profileCurrent);
    if(resp.ok!==false){ c.blocked = false; saveState(); renderContacts(); openProfileModal(profileCurrent); alert('Utilisateur débloqué'); }
    else { c.blocked = false; saveState(); renderContacts(); openProfileModal(profileCurrent); alert('Débloqué local (backend non disponible)'); }
  }
});
closeProfileBtn.addEventListener('click', ()=> profileModal.style.display = 'none');

/* CHAT open & send */
async function openChat(other17, contactObj=null){
  if(!me.tf17){ if(!await promptForMeModal()) return; }
  currentPartner = { tf17: other17, name: (contactObj && contactObj.name) || null };
  chatNameEl.textContent = currentPartner.name || formatTFShort(currentPartner.tf17);
  document.getElementById('chatAvatar').textContent = initials(currentPartner.name || currentPartner.tf17);
  const c = contacts.find(x=>x.tf17===other17);
  if(c){ c.unread = 0; saveState(); renderContacts(); }
  messagesContainer.innerHTML = '<div class="muted">Chaje mesaj...</div>';
  try { await loadConversation(me.tf17, other17); } catch(e){ messagesContainer.innerHTML = `<div class="muted">Erreur: ${escapeHtml(e.message||e)}</div>`; }
  composer.style.display = 'flex';
}

sendBtn.addEventListener('click', sendMessage);
composerInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendMessage(); } });

async function sendMessage(){
  const txt = (composerInput.value||'').trim();
  if(!txt || !currentPartner) return;
  if(!me.tf17){ alert('Mete TFID nan Paramètres'); return; }
  // check blocked (call backend if available)
  const check = await apiCheckBlocked(currentPartner.tf17, me.tf17).catch(()=>null);
  // check means: does recipient block me?
  // Backend should return { ok:true, blockedByOther: true/false, youBlockedOther: true/false }
  if(check && (check.blockedByOther === true)){
    alert('Ou bloke pa itilizatè sa — mesaj pa pral delivre.');
    // show optimistic single-check but don't attempt apiAdd
    const cid = makeCid();
    addOrUpdateMessageToCache(me.tf17, currentPartner.tf17, { id:null, cid, from: me.tf17, text: txt, parsed_time: nowISO(), created_at: nowISO() });
    renderConversation(me.tf17, currentPartner.tf17);
    composerInput.value = '';
    return;
  }
  // local blocked check
  const c = contacts.find(x=>x.tf17===currentPartner.tf17);
  if(c && c.blocked){ alert('Ou bloke kontak sa — ou pa ka voye mesaj.'); return; }
  const cid = makeCid();
  const payload = { type:'text', from: me.tf17, text: txt, time: nowISO(), cid, name: me.name || null };
  addOrUpdateMessageToCache(me.tf17, currentPartner.tf17, { id:null, cid, from: me.tf17, text: txt, parsed_time: payload.time, created_at: payload.time });
  renderConversation(me.tf17, currentPartner.tf17);
  composerInput.value = '';
  if(c){ c.lastMsg = txt; c.lastTs = Date.now(); saveState(); renderContacts(); }
  try { await apiAdd(currentPartner.tf17, payload); startShortPollForMessage(currentPartner.tf17, cid); } catch(e){ alert('Envoi echoué: ' + (e.message||e)); }
}

function startShortPollForMessage(target17, cid){
  let tries = 0; const maxTries = 6; const interval = 1200;
  const attempt = async ()=>{
    tries++;
    try {
      const rows = await apiList(target17);
      const found = rows.find(r => { try { const p = JSON.parse(r.content); return p && p.cid === cid; } catch(e){ return false; } });
      if(found){ await loadConversation(me.tf17, target17); return true; }
    } catch(e){}
    if(tries < maxTries) setTimeout(attempt, interval);
  };
  attempt();
}

/* WEBSOCKET */
function connectWS(){
  if(!me.tf17){ wsStatus.textContent = 'WS: non connecté (pas de TFID)'; return; }
  try {
    ws = new WebSocket(WS_URL);
  } catch(e){ scheduleReconnect(); return; }
  ws.onopen = ()=>{ wsStatus.textContent = 'WS: connecté'; try{ ws.send(JSON.stringify({ type:'subscribe', tfid: me.tf17 })); } catch(e){} };
  ws.onmessage = (ev)=>{
    try {
      const data = JSON.parse(ev.data);
      if(data.type === 'subscribed') return;
      if(data.type === 'message'){
        const payload = data;
        let parsed = null;
        try{ parsed = JSON.parse(payload.content); } catch(e){ parsed = null; }
        if(!parsed || !parsed.from) return;
        const recipient = payload.tfid || null;
        const from = parsed.from;
        const other = (recipient === me.tf17) ? from : recipient;
        if(!other) return;
        const created = parsed.time || payload.created_at || nowISO();
        const msgObj = { id: payload.id || null, cid: parsed.cid || null, from, text: parsed.text || parsed.message || '', parsed_time: parsed.time || null, _db_created_at: payload.created_at || null, created_at: created };
        // if we have block info locally: if we blocked sender, ignore
        const cLocal = contacts.find(x=>x.tf17===other);
        if(cLocal && cLocal.blocked && msgObj.from === other){
          // drop message (we blocked them)
          return;
        }
        addOrUpdateMessageToCache(me.tf17, other, msgObj);
        // update contact name/photo if present
        if(parsed.name || parsed.photo){
          const c = ensureContactInList(other, parsed.name || null);
          if(parsed.name) c.name = parsed.name;
          if(parsed.photo) c.logo = parsed.photo;
          c.lastMsg = msgObj.text;
          c.lastTs = Date.now();
          saveState();
          renderContacts();
        }
        if(currentPartner && currentPartner.tf17 === other){ renderConversation(me.tf17, other); }
        else if(recipient === me.tf17){
          const c = ensureContactInList(other, parsed && parsed.name ? parsed.name : null);
          c.unread = (c.unread||0) + 1;
          c.lastMsg = msgObj.text;
          c.lastTs = Date.now();
          saveState();
          renderContacts();
        }
      }
    } catch(err){ console.warn('WS parse err', err); }
  };
  ws.onclose = ()=>{ wsStatus.textContent = 'WS: déconnecté'; scheduleReconnect(); };
  ws.onerror = (e)=>{ console.warn('WS error', e); wsStatus.textContent = 'WS: erreur'; try{ ws.close(); }catch(e){} };
}
function scheduleReconnect(){ if(reconnectTimer) return; reconnectTimer = setTimeout(()=>{ reconnectTimer=null; connectWS(); }, 3000); }

/* SEARCH */
document.getElementById('searchBtn').addEventListener('click', async ()=> await performSearchQuery(document.getElementById('searchInput').value.trim()));
document.getElementById('searchInput').addEventListener('keydown', async (e)=>{ if(e.key==='Enter'){ e.preventDefault(); await performSearchQuery(e.target.value.trim()); }});

async function performSearchQuery(raw){
  if(!raw) return;
  const digits = normalizeInputToDigits(raw);
  if(!digits){ renderContacts(); return; }
  if(digits.length < 7){ alert('TFID dwe gen omwen 7 chif.'); return; }
  const short7 = digits.slice(-7);
  const tf17 = to17(short7);
  let local = contacts.find(c => c.tf17 === tf17);
  if(local){ openChat(local.tf17, local); return; }
  try {
    const rows = await apiList(tf17);
    if(rows && rows.length > 0){
      const last = rows[rows.length-1] || rows[0];
      let lastMsg = '';
      try{ const p = JSON.parse(last.content); lastMsg = p.text || p.message || last.content; } catch(e){ lastMsg = last.content || ''; }
      const nameFromServer = (() => { try { const p = JSON.parse(last.content); return p.name || null } catch(_) { return null } })();
      const photoFromServer = (() => { try { const p = JSON.parse(last.content); return p.photo || null } catch(_) { return null } })();
      const c = { tf17, name: nameFromServer || formatTFShort(short7), lastMsg, lastTs: Date.now(), unread: 0, blocked:false, logo: photoFromServer||null };
      contacts.unshift(c); saveState(); renderContacts(); openChat(c.tf17, c); return;
    } else {
      if(confirm('Pa jwenn done sou servèr. Kreye kontak lokal pou TFID sa a?')){
        const c = { tf17, name: formatTFShort(short7), lastMsg: '', lastTs: Date.now(), unread:0, blocked:false, logo:null };
        contacts.unshift(c); saveState(); renderContacts(); openChat(c.tf17, c);
      }
    }
  } catch(err){ alert('Erè lè w ap chèche sou servèr: ' + (err.message||err)); }
}

/* SETTINGS modal behavior */
function updateSettingsUI(){ profileNameInput.value = me.name || ''; profileTfidInput.value = (me.tf17 || '').replace(/^TF-?/i,'').slice(-7); profilePwInput.value = ''; }
document.getElementById('settingsModal')?.addEventListener('click', (e)=>{ if(e.target === settingsModal) settingsModal.style.display = 'none'; });
document.getElementById('settingsCancel')?.addEventListener('click', ()=> settingsModal.style.display = 'none');

document.getElementById('profileSave').addEventListener('click', async ()=>{
  const nameVal = profileNameInput.value.trim();
  const short = normalizeInputToDigits(profileTfidInput.value.trim());
  if(!short || short.length < 7){ alert('TFID pa valab — antre 7 chif.'); return; }
  const tfShort = short.slice(-7);
  const tf17 = to17(tfShort);

  // if existing account has stored password require unlock when switching
  const existingHash = getPasswordHash(tf17);
  if(existingHash && (!me.tf17 || me.tf17 !== tf17)){
    const pw = prompt('Kont sa deja egziste lokalman. Antre modpas li pou itilize li:');
    if(!pw){ alert('Modpas obligatwa.'); return; }
    const has = await hashPasswordHex(pw);
    if(has !== existingHash){ alert('Modpas pa kòrèk.'); return; }
  }

  const newPw = profilePwInput.value || '';
  if(newPw){
    const hex = await hashPasswordHex(newPw);
    storePasswordHash(tf17, hex);
  }

  me.name = nameVal || me.name;
  me.short = tfShort;
  me.tf17 = tf17;
  saveState();
  settingsModal.style.display = 'none';
  await registerFrontendIfNeeded();
  if(ws && ws.readyState === WebSocket.OPEN){ try{ ws.send(JSON.stringify({ type:'subscribe', tfid: me.tf17 })); }catch(e){} } else connectWS();
  if(!hasPasswordFor(me.tf17)) pwBanner.style.display = 'block'; else pwBanner.style.display = 'none';
});

/* promptForMeModal on first load */
async function promptForMeModal(){
  updateSettingsUI();
  settingsModal.style.display = 'flex';
  return new Promise(resolve=>{
    function onSave(){ profileSave.click(); cleanup(); resolve(true); }
    function onCancel(){ settingsModal.style.display = 'none'; cleanup(); resolve(false); }
    function cleanup(){ document.getElementById('profileSave').removeEventListener('click', onSave); settingsCancel.removeEventListener('click', onCancel); }
    document.getElementById('profileSave').addEventListener('click', onSave);
    settingsCancel.addEventListener('click', onCancel);
  });
}

/* register frontend if needed (same as before) */
async function registerFrontendIfNeeded(){
  try {
    const url = `${API_BASE}/admin/register-frontend`;
    const payload = { name: FRONTEND_NAME, callback_url: location.origin };
    const r = await callJSON(url, { method:"POST", headers:{"Content-Type":"application/json","x-api-token": ADMIN_API_TOKEN}, body: JSON.stringify(payload) });
    return r.ok;
  } catch(e){ return false; }
}

/* IMAGE UPLOAD: upload to IMAGE_UPLOAD_BASE and push profile update to contacts */
uploadBtn.addEventListener('click', async ()=>{
  const f = profileFile.files && profileFile.files[0];
  if(!f){ alert('Choisissez une image.'); return; }
  if(!f.type.startsWith('image/')){ alert('Se sèlman image (jpg/png) ki valab.'); return; }
  const fd = new FormData();
  fd.append('file', f);
  uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading...';
  try {
    const resp = await fetch(IMAGE_UPLOAD_BASE, { method:'POST', body: fd });
    const json = await resp.json().catch(()=>null);
    if(!resp.ok || !json || !json.ok || !json.url){ alert('Upload échoué'); uploadBtn.disabled=false; uploadBtn.textContent='Uploader'; return; }
    const url = json.url;
    me.avatarDataUrl = url; saveState();
    // push profile update to each contact via apiAdd with type=profile
    for(const c of contacts){
      try{
        const cid = makeCid();
        const payload = { type:'profile', from: me.tf17, name: me.name, photo: url, time: nowISO(), cid };
        await apiAdd(c.tf17, payload);
      } catch(e){
        // ignore per-contact errors
      }
    }
    alert('Upload OK et profile poussé.');
  } catch(e){
    alert('Upload erreur: ' + (e.message||e));
  } finally { uploadBtn.disabled=false; uploadBtn.textContent='Uploader'; }
});

/* BOOT */
renderContacts();
if(me.tf17){ connectWS(); if(!hasPasswordFor(me.tf17)) pwBanner.style.display = 'block'; } else { setTimeout(()=>{ promptForMeModal(); }, 250); }

/* utility expose */
window._tf_contacts = contacts;
window._tf_me = me;
</script>
</body>
        </html>
