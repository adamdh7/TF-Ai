<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TF-Chat — Simple</title>
<style>
  :root{--bg:#f2f2f5;--card:#fff;--muted:#7a7a7a;--accent:#128C7E;--green:#25D366}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#111}
  .wrap{max-width:900px;margin:0 auto;height:100vh;display:flex;flex-direction:column}
  header{height:84px;display:flex;align-items:flex-end;padding:14px 16px;background:linear-gradient(180deg, #fff, rgba(255,255,255,0.8))}
  .title{font-weight:800;font-size:22px}
  main{flex:1;overflow:auto;padding:12px}
  .card{background:var(--card);padding:12px;border-radius:12px;margin-bottom:12px;box-shadow:0 1px 0 rgba(0,0,0,0.04)}
  .search{width:100%;padding:12px;border-radius:12px;border:1px solid #eee;font-size:16px}
  .row{display:flex;gap:8px;margin-top:8px}
  button{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:#fff;cursor:pointer;font-weight:700}
  .btn-ghost{background:transparent;color:var(--accent);border:1px solid rgba(18,140,126,0.12)}
  .contacts{display:flex;flex-direction:column;gap:8px}
  .contact{display:flex;align-items:center;gap:12px;padding:12px;background:#fff;border-radius:10px;cursor:pointer;border:1px solid #f0f0f0}
  .avatar{width:56px;height:56px;border-radius:50%;background:#ddd;flex-shrink:0}
  .chat-page{display:flex;flex-direction:column;height:calc(100vh - 160px)}
  .chat-head{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid #eee}
  .chat-body{flex:1;overflow:auto;padding:12px;background:linear-gradient(#f2f2f5,#f2f2f5)}
  .messages{display:flex;flex-direction:column;gap:8px}
  .bubble{max-width:78%;padding:10px 12px;border-radius:14px;background:#fff;align-self:flex-start;word-break:break-word}
  .bubble.me{background:#dcf8c6;align-self:flex-end}
  .composer{display:flex;gap:8px;padding:10px;border-top:1px solid #eee;background:var(--card)}
  input[type="text"], textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #eee}
  .small{font-size:13px;color:var(--muted)}
  .link-tfid{color:var(--accent);text-decoration:underline;cursor:pointer}
  @media(min-width:900px){ .wrap{border-left:1px solid rgba(0,0,0,0.04);border-right:1px solid rgba(0,0,0,0.04)} }
</style>
</head>
<body>
<div class="wrap" id="app">
  <header>
    <div>
      <div class="title">TF-Chat</div>
      <div class="small" id="meLabel">...</div>
    </div>
  </header>

  <main id="main">
    <div class="card">
      <input id="searchInput" class="search" placeholder="Entrer TFID (ex: TF-0204143 ou 0204143) puis Appuyer Rechercher">
      <div class="row" style="margin-top:10px">
        <button id="btnSearch">Rechercher</button>
        <button id="btnMyProfile" class="btn-ghost">Mon profil / Paramètres</button>
      </div>
    </div>

    <div id="contentArea">
      <div class="card">
        <div class="small">Contacts récents</div>
        <div id="contacts" class="contacts"></div>
      </div>
      <div id="chatContainer"></div>
    </div>
  </main>
</div>

<script>
/*
  Simple TF-Chat frontend:
  - Generate TFID (TF-xxxxxxx) for visitor and store in localStorage
  - Search TFID -> check https://tf-sove.onrender.com/api/list?tfid=<17>&name=Adam_DH7
  - If found, open chat, allow send; messages stored via POST /api/add
  - Poll own TFID every 3s to get messages
*/
const CONFIG = {
  SAVE_HOST: "https://tf-sove.onrender.com",
  API_LIST: "/api/list",
  API_ADD: "/api/add",
  API_TOKEN: "tfstream_45dd9c02d4e34f18a42d",
  FRONTEND_NAME: "Adam_DH7",
  UI_DIGITS: 7,
  SERVER_DIGITS: 17,
  POLL_MS: 3000,
  SESSION_KEY: "tfchat_session"
};

let state = {
  me: null,         // { ui, server, name, avatar }
  contacts: [],     // [{ui, server, name}]
  messages: {},     // server -> [ {id, from, text, time} ]
  pollId: null,
  currentChatServer: null
};

/* helpers */
function el(tag, cls){ const e = document.createElement(tag); if(cls) e.className = cls; return e; }
function uiRandom(){ return 'TF-' + Math.floor(Math.random()*1e7).toString().padStart(CONFIG.UI_DIGITS,'0'); }
function extractDigits(s){ const m = String(s||'').match(/\d+/g); return m? m.join('') : ''; }
function uiNormalize(v){ v = String(v||'').trim(); if(!v) return ''; if(v.startsWith('TF-')) return v; const d = extractDigits(v); return 'TF-' + d.padStart(CONFIG.UI_DIGITS,'0'); }
function uiToServer(ui){ const d = extractDigits(ui); if(!d) throw new Error('TFID invalide'); return d.padStart(CONFIG.SERVER_DIGITS,'0'); }
function now(){ return new Date().toISOString(); }
function saveSession(){ if(state.me) localStorage.setItem(CONFIG.SESSION_KEY, JSON.stringify(state.me)); else localStorage.removeItem(CONFIG.SESSION_KEY); }
function loadSession(){ try{ const s = localStorage.getItem(CONFIG.SESSION_KEY); return s? JSON.parse(s):null }catch(e){return null} }

/* network */
async function apiList(serverTfid){
  const url = new URL(CONFIG.SAVE_HOST + CONFIG.API_LIST);
  url.searchParams.set('tfid', serverTfid);
  url.searchParams.set('name', CONFIG.FRONTEND_NAME);
  const resp = await fetch(url.toString(), { headers: { 'x-api-token': CONFIG.API_TOKEN }});
  if(!resp.ok) throw new Error('list failed ' + resp.status);
  return resp.json();
}
async function apiAdd(serverTfid, contentObj){
  const body = { tfid: serverTfid, name: CONFIG.FRONTEND_NAME, content: JSON.stringify(contentObj) };
  const resp = await fetch(CONFIG.SAVE_HOST + CONFIG.API_ADD, {
    method: 'POST',
    headers: { 'Content-Type':'application/json', 'x-api-token': CONFIG.API_TOKEN },
    body: JSON.stringify(body)
  });
  if(!resp.ok) throw new Error('add failed ' + resp.status);
  return resp.json();
}

/* UI wiring */
const meLabel = document.getElementById('meLabel');
const searchInput = document.getElementById('searchInput');
const btnSearch = document.getElementById('btnSearch');
const btnMyProfile = document.getElementById('btnMyProfile');
const contactsDiv = document.getElementById('contacts');
const chatContainer = document.getElementById('chatContainer');

btnSearch.onclick = async ()=>{
  const v = (searchInput.value || '').trim();
  if(!v){ alert('Entrer un TFID'); return; }
  let ui;
  try{ ui = uiNormalize(v); }catch(e){ alert('TFID invalide'); return; }
  const server = uiToServer(ui);
  // call backend list to check existence
  try{
    showStatus('Recherche...');
    const j = await apiList(server);
    // if backend responds ok and rows present => open chat
    if(j && j.ok){
      // open chat with that server
      openChat(server, ui);
    } else {
      alert('TFID introuvable sur le serveur.');
    }
  }catch(err){
    console.warn(err);
    alert('Erreur réseau / tfid introuvable');
  }finally{ showStatus(''); }
};

btnMyProfile.onclick = ()=>{
  const name = prompt('Votre nom / pseudo', state.me.name || state.me.ui) || state.me.name || state.me.ui;
  state.me.name = name;
  saveSession();
  updateHeader();
  alert('Nom enregistré localement. (profil sera partagé via messages si besoin)');
};

/* render contacts */
function renderContacts(){
  contactsDiv.innerHTML = '';
  state.contacts.forEach(c=>{
    const row = el('div','contact');
    row.innerHTML = `<div class="avatar"></div><div><strong>${c.name||c.ui}</strong><div class="small">${c.ui}</div></div>`;
    row.onclick = ()=> openChat(c.server, c.ui);
    contactsDiv.appendChild(row);
  });
}

/* open chat */
async function openChat(serverTfid, ui){
  state.currentChatServer = serverTfid;
  chatContainer.innerHTML = '';
  const page = el('div','card');
  const head = el('div','chat-head');
  head.innerHTML = `<div style="display:flex;gap:12px;align-items:center"><div class="avatar"></div><div><strong>${ui}</strong><div class="small">${ui}</div></div></div>`;
  page.appendChild(head);

  const chatPage = el('div','chat-page');
  const chatBody = el('div','chat-body');
  const msgs = el('div','messages');
  chatBody.appendChild(msgs);
  chatPage.appendChild(chatBody);

  const composer = el('div','composer');
  const input = el('input'); input.type='text'; input.placeholder='Écrire un message...';
  const sendBtn = el('button'); sendBtn.textContent = 'Envoyer';
  composer.appendChild(input); composer.appendChild(sendBtn);
  chatPage.appendChild(composer);
  page.appendChild(chatPage);
  chatContainer.appendChild(page);

  // load existing messages for this target (serverTfid)
  state.messages[serverTfid] = state.messages[serverTfid] || [];
  try{
    const j = await apiList(serverTfid);
    if(j && j.ok && Array.isArray(j.rows)){
      // rows are newest first in server code; show ascending
      const rows = j.rows.slice().reverse();
      rows.forEach(r=>{
        let payload;
        try{ payload = JSON.parse(r.content); }catch(e){ payload = { type:'text', text: r.content }; }
        if(payload.type === 'text' || payload.type === 'file'){
          state.messages[serverTfid].push({ id: r.id, from: payload.from || 'unknown', text: payload.text || payload.message || '', time: r.created_at });
        }
      });
    }
  }catch(e){ console.warn('load messages error', e); }

  function renderMessages(){
    msgs.innerHTML = '';
    const arr = state.messages[serverTfid] || [];
    arr.forEach(m=>{
      const b = el('div','bubble' + ((state.me && m.from === state.me.server) ? ' me' : ''));
      // transform TF-xxxxx in text to clickable
      const text = String(m.text || '').replace(/TF-(\d+)/g, match => `<span class="link-tfid">${match}</span>`);
      b.innerHTML = text + `<div class="small" style="text-align:right;margin-top:6px">${(m.time? new Date(m.time).toLocaleTimeString(): '')}</div>`;
      // attach click handlers for any link-tfid
      setTimeout(()=> b.querySelectorAll('.link-tfid').forEach(el=> el.onclick = ()=> {
        const u = el.textContent; // open contact if exists else open chat create
        try{
          const srv = uiToServer(u);
          if(state.contacts.some(c=>c.server===srv)) openChat(srv, u);
          else {
            // create contact entry and open chat
            const contact = { ui:u, server:srv, name:u };
            state.contacts.unshift(contact);
            renderContacts();
            openChat(srv, u);
          }
        }catch(err){ console.warn(err); alert('TFID invalide'); }
      }), 0);
      msgs.appendChild(b);
    });
    msgs.scrollTop = msgs.scrollHeight;
  }

  renderMessages();

  sendBtn.onclick = async ()=>{
    const txt = input.value.trim(); if(!txt) return;
    if(!state.me){ alert('Profil non configuré'); return; }
    // optimistic push locally
    const localM = { id: null, from: state.me.server, text: txt, time: now() };
    state.messages[serverTfid] = state.messages[serverTfid] || [];
    state.messages[serverTfid].push(localM);
    renderMessages();
    input.value = '';
    // build payload
    const payload = { type:'text', from: state.me.server, text: txt, time: now() };
    try{
      const r = await apiAdd(serverTfid, payload); // write to recipient timeline
      // also write to sender timeline (so sender sees message)
      await apiAdd(state.me.server, payload).catch(()=>{});
      if(r && r.id){ localM.id = r.id; }
    }catch(err){
      console.warn('send error', err); alert('Envoi échoué');
    }
    renderMessages();
  };
}

/* polling own timeline */
async function pollOwn(){
  if(!state.me) return;
  try{
    const j = await apiList(state.me.server);
    if(j && j.ok && Array.isArray(j.rows)){
      // append unseen messages
      const rows = j.rows.slice().reverse();
      for(const r of rows){
        // check if id present in state.messages for that target (r.tfid)
        const tgt = r.tfid;
        state.messages[tgt] = state.messages[tgt] || [];
        if(state.messages[tgt].some(m=>m.id === r.id)) continue;
        let payload;
        try{ payload = JSON.parse(r.content); }catch(e){ payload = { type:'text', text: r.content }; }
        if(payload.type === 'text' || payload.type === 'file'){
          const mobj = { id: r.id, from: payload.from || 'unknown', text: payload.text || payload.message || '', time: r.created_at };
          state.messages[tgt].push(mobj);
          // if currently viewing that chat, re-render
          if(state.currentChatServer === tgt && window.renderChatRefresh) window.renderChatRefresh(tgt);
        }
      }
    }
  }catch(e){ /* silent */ }
}

/* init */

  function init() {
  const s = loadSession();

  if (s && s.ui && s.server) {
    state.me = s;
  } else {
    // ✅ Toujou kreye yon TF-ID valab
    const randomNum = Math.floor(1000000 + Math.random() * 8999999);
    const ui = `TF-${randomNum}`;
    const server = uiToServer(ui);

    state.me = {
      ui,
      server,
      name: "Moi"
    };

    saveSession();
  }

  // ✅ Mizajou header la
  meLabel.textContent = `${state.me.name} • ${state.me.ui}`;

  // ✅ Ajoute kontak default la si pa egziste
  if (!state.contacts.some(c => c.ui === "TF-7777777")) {
    state.contacts.unshift({
      ui: "TF-7777777",
      server: uiToServer("TF-7777777"),
      name: "Adam_D'H7"
    });
  }

  renderContacts();

  // ✅ Kòmanse polling pou mesaj yo
  pollOwn();
  state.pollId = setInterval(pollOwn, CONFIG.POLL_MS);
  }

/* helper status */
function showStatus(t){ /* optionally show network status; minimal for now */ console.log('status', t); }

/* expose for debugging */
window.TFCHAT = { state, apiList, apiAdd, uiNormalize, uiToServer, pollOwn };

</script>
</body>
</html>
