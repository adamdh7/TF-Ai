<!doctype html>
<html lang="ht">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>TF-Chat</title>
<link rel="icon" href="https://files.catbox.moe/ixgmht.jpg" />
<meta name="theme-color" content="#000000">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#000000; --panel:#000000; --text:#e6eefb; --muted:#9aa6bf;
  --card:#0b0b0b; --accent:#0b81ff; --header-h:56px; --tab-h:62px;
  --msg-line-height:1.35rem; --msg-max-lines:8;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Roboto,system-ui,Arial,sans-serif;-webkit-font-smoothing:antialiased}
header{position:fixed;left:0;right:0;top:0;height:var(--header-h);display:flex;align-items:center;justify-content:center;background:var(--panel);z-index:1000;border-bottom:1px solid rgba(255,255,255,0.03)}
.app-title{font-weight:700;font-size:18px;cursor:pointer}
main{position:fixed;left:0;right:0;top:var(--header-h);bottom:var(--tab-h);overflow:auto;padding:12px;margin:0 auto;max-width:980px}
body.chat-open main > section { display:none !important; }
.tabbar { position:fixed; left:0; right:0; bottom:0; height:var(--tab-h); display:flex; gap:0; border-top:1px solid rgba(255,255,255,0.03); background:var(--panel); align-items:center; justify-content:center; z-index:1000; }
.tab { flex:1; text-align:center; padding:10px 6px; cursor:pointer; font-weight:700; color:var(--muted); }
.tab.active{ color:var(--text); border-top:3px solid var(--accent); background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }
.search{padding:8px 12px;display:flex;justify-content:center}
.search-box{display:flex;align-items:center;gap:8px;background:var(--card);padding:10px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);width:100%;max-width:980px}
.search-box input{flex:1;background:transparent;border:0;outline:none;color:var(--text);font-size:15px}
.search-btn{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
.list{margin-top:12px}
.contact{display:flex;gap:12px;align-items:center;padding:12px;border-radius:12px;cursor:pointer;width:100%}
.contact:hover{background:rgba(255,255,255,0.02)}
.avatar{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));display:inline-flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;color:var(--text);flex-shrink:0;overflow:hidden}
.avatar img{width:100%;height:100%;object-fit:cover;border-radius:50%}
.meta{flex:1;min-width:0}
.meta-top{display:flex;justify-content:space-between;align-items:flex-start}
.name{font-weight:600;font-size:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.time{font-size:12px;color:var(--muted)}
.meta-bottom{display:flex;justify-content:space-between;margin-top:6px;align-items:center}
.snippet{font-size:13px;color:var(--muted);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.badge{background:var(--accent);color:white;padding:4px 8px;border-radius:999px;font-weight:600;font-size:13px}
.group-manage-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:6px 8px;border-radius:8px;cursor:pointer;font-weight:600;margin-left:8px}
.messages-wrap{padding:12px;height:calc(100% - 56px - 84px);overflow:auto;display:flex;flex-direction:column;gap:8px}
.messages{display:flex;flex-direction:column;gap:8px}
.msg{max-width:74%;padding:10px;border-radius:12px;margin-bottom:4px;word-break:break-word;overflow:hidden;display:inline-block}
.msg.bot{background:#121212;color:var(--text);align-self:flex-start}
.msg.user{background:linear-gradient(180deg,var(--accent),#0563c9);color:white;align-self:flex-end}
.msg .checks{font-size:11px;margin-left:8px;opacity:0.95}
.msg-text{ white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; display:block; line-height: var(--msg-line-height); max-height: calc(var(--msg-line-height) * var(--msg-max-lines)); }
.msg-meta{font-size:11px;color:var(--muted);margin-top:6px;display:flex;gap:8px;align-items:center}
.chat-input{display:flex;gap:8px;align-items:center;padding:12px;border-top:1px solid rgba(255,255,255,0.03);background:transparent}
.input{flex:1;padding:12px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);background:var(--card);color:var(--text);outline:none;min-width:0}
.send-btn{background:transparent;border:0;padding:8px;border-radius:10px;cursor:pointer;color:var(--accent);display:inline-flex;align-items:center;justify-content:center}
.send-icon{width:22px;height:22px;transform:rotate(-45deg);display:block}
.muted{text-align:center;color:var(--muted);padding:20px}
@media (max-width:640px){
  .avatar{width:48px;height:48px}
  main{ padding:10px; }
}
</style>
</head>
<body>
  <header><div class="app-title">TF-Chat</div></header>
  <div class="banner" id="pwBanner">Tanpri mete yon modpas pou sekirize sesyon ou. Ou gen 2 min pou sove li.</div>

  <main>
    <section id="section-accueil">
      <section class="search">
        <div class="search-box" role="search">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" aria-hidden="true"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6"/><circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.6"/></svg>
          <input id="searchInput" placeholder="Recherche (TFID ou 7 chif)" aria-label="Recherche" />
          <button id="searchBtn" class="search-btn">Rechercher</button>
        </div>
      </section>
      <section class="list" id="contactsList" aria-live="polite"></section>
    </section>

    <section id="section-groupes" style="display:none">
      <section class="search">
        <div class="search-box" role="search">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" aria-hidden="true"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6"/><circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.6"/></svg>
          <input id="groupSearchInput" placeholder="Chercher un groupe…" aria-label="Recherche groupe" />
          <button id="groupSearchBtn" class="search-btn">Recherche</button>
        </div>
      </section>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
        <div style="font-weight:700">Mes groupes</div>
        <button id="openCreateGroup" class="search-btn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 12px;border-radius:10px">Créer</button>
      </div>
      <section class="list" id="groupsList" aria-live="polite" style="margin-top:12px"></section>
    </section>
  </main>

  <div class="tabbar">
    <div id="tabAccueil" class="tab active">Accueil</div>
    <div id="tabGroupes" class="tab">Groupes</div>
  </div>

  <!-- Chat modal -->
  <div id="chatModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.96);z-index:1200">
    <div style="height:100%;display:flex;flex-direction:column">
      <div style="height:56px;display:flex;align-items:center;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.03)">
        <button id="chatBack" style="background:transparent;border:0;color:var(--text);cursor:pointer">←</button>
        <div style="flex:1;text-align:center;font-weight:700;cursor:pointer" id="chatTitle">Chat</div>
        <div style="width:44px"></div>
      </div>
      <div class="messages-wrap">
        <div class="messages" id="messages" aria-live="polite" role="log"></div>
      </div>
      <div class="chat-input" id="chatInputRow">
        <input id="chatText" class="input" placeholder="Ekri mesaj..." autocomplete="off" />
        <button id="sendBtn" class="send-btn" aria-label="Envoyer" title="Envoyer">
          <!-- send icon similar to whatsapp (rotated paper plane) -->
          <svg class="send-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M22 2L11 13"></path>
            <path d="M22 2L15 22L11 13L2 9L22 2Z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- minimal modals omitted (same as previous) -->

<script>
/* ================== CONFIG ================== */
const API_BASE = 'https://tf-sove.onrender.com';
const PROFILE_UPLOAD_URL = API_BASE + '/upload';
const FRONTEND_NAME = 'site1';
const ADMIN_API_TOKEN = 'tfstream_45dd9c02d4e34f18a42d';
const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + "tf-sove.onrender.com/ws";

/* ================== HELPERS ================== */
function normalizeInputToDigits(inp){ if(!inp) return null; const s=String(inp).trim().toUpperCase(); const digits=s.replace(/[^0-9]/g,''); return digits||null; }
function to17(shortOrDigits){ if(!shortOrDigits) return null; const ds=String(shortOrDigits).replace(/[^0-9]/g,''); if(ds.length>17) return ds.slice(-17); return ds.padStart(17,'0'); }
function formatTFShort(digitsString){ if(!digitsString) return ''; const s=String(digitsString).replace(/[^0-9]/g,''); const last7 = s.slice(-7); return 'TF-'+ last7.padStart(7,'0'); }
function nowISO(){ return (new Date()).toISOString(); }
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function makeCid(){ return String(Date.now()) + '-' + Math.floor(Math.random()*100000).toString(16); }
function parseDatePrefer(isoOrDb, parsedTime){ const t1 = parsedTime ? Date.parse(parsedTime) : NaN; if(!isNaN(t1)) return t1; const t2 = Date.parse(isoOrDb || ""); return isNaN(t2) ? 0 : t2; }
async function hashPasswordHex(pw){ const enc = new TextEncoder(); const data = enc.encode(String(pw)); const hashBuffer = await crypto.subtle.digest('SHA-256', data); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b => b.toString(16).padStart(2,'0')).join(''); }
function isValidTfid(tfid){ return typeof tfid === 'string' && /^\d{17}$/.test(tfid); }
function normParticipant(id){ if(!id) return ''; const s = String(id).trim(); if(s.startsWith('GROUP:')) return s; const digits = s.replace(/[^0-9]/g,''); if(!digits) return ''; if(digits.length >= 17) return to17(digits.slice(-17)); if(digits.length >= 7) return to17(digits.slice(-7)); return to17(digits); }

/* ================== STATE ================== */
let me = {
  short: localStorage.getItem('tfchat.me.short') || null,
  tf17: localStorage.getItem('tfchat.me.17') || null,
  name: localStorage.getItem('tfchat.me.name') || 'Utilisateur',
  avatarDataUrl: localStorage.getItem('tfchat.me.avatar') || null
};
if(me.tf17) me.tf17 = normParticipant(me.tf17);
let contacts = JSON.parse(localStorage.getItem('tfchat.contacts') || '[]') || [];
contacts = contacts.map(c => { if(c && c.tf17) c.tf17 = normParticipant(c.tf17) || c.tf17; return c; });
let groups = JSON.parse(localStorage.getItem('tfchat.groups') || '[]') || [];
let ws = null; let reconnectTimer = null; let currentPartner = null; let currentGroup = null;
const conversationCache = {};
let pwWarningTimer = null; let pwForceReloadTimer = null;

/* ================== DOM REFS ================== */
const messagesEl = document.getElementById('messages');
const chatTextEl = document.getElementById('chatText');
const sendBtnEl = document.getElementById('sendBtn');
const chatModalEl = document.getElementById('chatModal');
const chatTitleEl = document.getElementById('chatTitle');
const profileSaveBtn = document.getElementById('profileSave');
const pwBanner = document.getElementById('pwBanner');

/* ================== STORAGE HELPERS ================== */
function saveState(){ localStorage.setItem('tfchat.me.short', me.short || ''); localStorage.setItem('tfchat.me.17', me.tf17 || ''); localStorage.setItem('tfchat.me.name', me.name || ''); if(me.avatarDataUrl) localStorage.setItem('tfchat.me.avatar', me.avatarDataUrl); localStorage.setItem('tfchat.contacts', JSON.stringify(contacts || [])); localStorage.setItem('tfchat.groups', JSON.stringify(groups || [])); }
function convKey(a,b){ const na = normParticipant(a); const nb = normParticipant(b); if(!na || !nb) return `${a}|${b}`; return `${na}|${nb}`; }
function saveConversationCacheForMe(){ const meN = normParticipant(me.tf17); if(!meN) return; const key = `tfchat.conversations.${meN}`; const out = {}; for(const k in conversationCache){ if(!conversationCache.hasOwnProperty(k)) continue; const parts = k.split('|'); if(parts.length !== 2) continue; const [a,b] = parts; if(a === meN) out[b] = conversationCache[k]; else if(b === meN) out[a] = conversationCache[k]; } try { localStorage.setItem(key, JSON.stringify(out)); } catch(e){ console.warn('save conv cache fail', e); } }
function loadConversationCacheForMe(){ const meN = normParticipant(me.tf17); if(!meN) return; const key = `tfchat.conversations.${meN}`; try{ const raw = localStorage.getItem(key); if(!raw) return; const obj = JSON.parse(raw||'{}'); for(const other in obj){ if(!obj.hasOwnProperty(other)) continue; const ck = convKey(meN, other); conversationCache[ck] = obj[other].slice(); } } catch(e){ console.warn('load conv cache fail', e); } }

/* ================== RENDER + LINKIFY ================== */
const URL_RE = /((https?:\/\/|www\.)[^\s<>]+)/gi;
function createMessageNodes(text){ const wrapper = document.createDocumentFragment(); if(!text){ wrapper.appendChild(document.createTextNode('')); return wrapper; } let lastIndex=0; let match; while((match=URL_RE.exec(text))!==null){ const idx = match.index; if(idx>lastIndex) wrapper.appendChild(document.createTextNode(text.slice(lastIndex,idx))); let url = match[0]; if(!/^https?:\/\//i.test(url)) url='http://'+url; const a=document.createElement('a'); a.href=url; a.target='_blank'; a.rel='noopener noreferrer'; a.textContent=match[0]; a.style.color='inherit'; a.style.textDecoration='underline'; a.style.cursor='pointer'; wrapper.appendChild(a); lastIndex = idx + match[0].length; } if(lastIndex < text.length) wrapper.appendChild(document.createTextNode(text.slice(lastIndex))); return wrapper; }

function renderConversation(me17, other17){
  const meN = normParticipant(me17); const otherN = normParticipant(other17);
  const key = convKey(meN, otherN); const arr = conversationCache[key] ? [...conversationCache[key]] : [];
  arr.sort((a,b)=>{ const ta=parseDatePrefer(a._db_created_at,a.parsed_time); const tb=parseDatePrefer(b._db_created_at,b.parsed_time); return ta-tb; });
  const parent = messagesEl?.parentElement; const wasAtBottom = parent ? (parent.scrollHeight - parent.scrollTop - parent.clientHeight < 60) : true;
  messagesEl.innerHTML = '';
  if(arr.length===0){ const d=document.createElement('div'); d.className='muted'; d.textContent='Pa gen mesaj ankò.'; messagesEl.appendChild(d); }
  else {
    for(const m of arr){
      // Skip system/read receipts in UI -- they are handled separately
      if(m._hidden) continue;
      const fromNorm = normParticipant(m.from);
      const isMe = fromNorm === meN;
      const d = document.createElement('div'); d.className = 'msg ' + (isMe ? 'user' : 'bot');
      const textBlock = document.createElement('div'); textBlock.className = 'msg-text'; textBlock.appendChild(createMessageNodes(m.text||''));
      const meta = document.createElement('div'); meta.className='msg-meta';
      const ts = m.created_at ? (new Date(m.created_at)).toLocaleString() : '';
      const checksSpan = document.createElement('span'); checksSpan.className='checks';
      if(isMe){
        // show double tick only when the message has been acknowledged as read by recipient
        if(m.read) checksSpan.textContent = '✓✓';
        else checksSpan.textContent = m.id ? '✓' : '✓'; // sent or optimistic
      }
      meta.textContent = `${formatTFShort(m.from||'')} • ${ts} `;
      meta.appendChild(checksSpan);
      d.appendChild(textBlock); d.appendChild(meta); messagesEl.appendChild(d);
    }
  }
  setTimeout(()=>{ if(!parent) return; if(wasAtBottom) parent.scrollTop = parent.scrollHeight; }, 40);
}

/* ================== NETWORK HELPERS ================== */
async function callJSON(url, opts = {}) { opts = Object.assign({}, opts); opts.headers = Object.assign({}, opts.headers||{}, {'Accept':'application/json'}); try { const r = await fetch(url, opts); const text = await r.text(); let json = null; try{ json = JSON.parse(text); }catch(e){} return { ok: r.ok, status: r.status, json, text }; } catch (err) { return { ok:false, error: err.message }; } }
async function apiList(tf17){ const url = `${API_BASE}/api/list?tfid=${encodeURIComponent(tf17)}&name=${encodeURIComponent(FRONTEND_NAME)}`; const r = await callJSON(url); if(!r.ok) throw new Error(r.json?.error || r.text || `HTTP ${r.status}`); return r.json.rows || []; }
async function apiAdd(recipient17, contentObj){ const body = { tfid: recipient17, name: FRONTEND_NAME, content: JSON.stringify(contentObj), source_url: location.origin }; const url = `${API_BASE}/api/add`; const r = await callJSON(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) }); if(!r.ok) { const errMsg = r.json?.error || r.text || `HTTP ${r.status}`; if(String(errMsg).toLowerCase().includes("frontend name not registered")) { const regOk = await registerFrontendIfNeeded(); if(regOk) { const r2 = await callJSON(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) }); if(!r2.ok) throw new Error(r2.json?.error || r2.text || `HTTP ${r2.status}`); return r2.json; } } throw new Error(errMsg); } return r.json; }
async function registerFrontendIfNeeded(){ try { const url = `${API_BASE}/admin/register-frontend`; const payload = { name: FRONTEND_NAME, callback_url: location.origin }; const r = await callJSON(url, { method:"POST", headers:{"Content-Type":"application/json","x-api-token": ADMIN_API_TOKEN}, body: JSON.stringify(payload) }); return r.ok; } catch(e){ return false; } }

/* ================== CONVERSATION LOAD + READ RECEIPT HANDLING ================== */
function addOrUpdateMessageToCache(me17, other17, msg){
  const key = convKey(me17, other17); if(!conversationCache[key]) conversationCache[key] = [];
  const list = conversationCache[key];
  const findIndex = msg.cid ? list.findIndex(x=>x.cid && x.cid===msg.cid) : (msg.id ? list.findIndex(x=>x.id && String(x.id)===String(msg.id)) : -1);
  if(findIndex !== -1) list[findIndex] = Object.assign({}, list[findIndex], msg); else list.push(msg);
  // ensure message objects have read flag default false
  for(const it of list){ if(typeof it.read === 'undefined') it.read = !!it.read; }
  list.sort((a,b)=> compareMessagesAsc(a,b));
  saveConversationCacheForMe();
}
function compareMessagesAsc(a,b){ const ta=parseDatePrefer(a._db_created_at,a.parsed_time); const tb=parseDatePrefer(b._db_created_at,b.parsed_time); if(ta!==tb) return ta-tb; if(a.id && b.id && a.id!==b.id) return Number(a.id)-Number(b.id); if(a.cid && b.cid && a.cid!==b.cid) return a.cid < b.cid ? -1 : 1; return 0; }

async function loadConversation(me17, other17){
  const meN = normParticipant(me17); const otherN = normParticipant(other17);
  loadConversationCacheForMe();
  const key = convKey(meN, otherN);
  conversationCache[key] = conversationCache[key] || [];
  const seen = new Set();

  function handleReadReceipt(parsed){
    // parsed contains cid or id and from = reader (who read messages), so mark messages the reader has sent as read
    const reader = normParticipant(parsed.from);
    const cid = parsed.cid || null;
    const id = parsed.id || null;
    // which side to update: messages where from === meN AND intended recipient === reader
    const ck = convKey(meN, reader);
    const list = conversationCache[ck] || [];
    let changed=false;
    for(const it of list){
      if(it.from && normParticipant(it.from) === meN){
        if(cid && it.cid && it.cid === cid){ if(!it.read){ it.read = true; changed=true; } }
        else if(id && it.id && String(it.id) === String(id)){ if(!it.read){ it.read = true; changed=true; } }
      }
    }
    if(changed) saveConversationCacheForMe();
    // if currently open chat with that reader, rerender
    if(currentPartner && normParticipant(currentPartner.tf17) === reader){ renderConversation(meN, reader); }
  }

  function pushRowFromServer(r){
    let parsed=null; try{ parsed = JSON.parse(r.content); }catch(e){ parsed=null; }
    if(parsed && parsed.type === 'read'){ // read receipt handling: don't display as message
      handleReadReceipt(parsed); return;
    }
    const parsedFromRaw = parsed && parsed.from ? parsed.from : null;
    if(!parsedFromRaw) return;
    const parsedFrom = normParticipant(parsedFromRaw);
    if(parsedFrom !== meN && parsedFrom !== otherN) return;
    const parsedTime = parsed && parsed.time ? parsed.time : null;
    const parsedCid = parsed && parsed.cid ? parsed.cid : null;
    const parsedText = parsed && (parsed.text || parsed.message) ? (parsed.text || parsed.message) : (r.content || "");
    const m = { id: r.id || null, cid: parsedCid || null, from: parsedFrom, text: parsedText, parsed_time: parsedTime || null, _db_created_at: r.created_at || null, created_at: parsedTime || r.created_at || nowISO(), _hidden: false, read: false };
    const keyu = messageUniqueKey(m);
    if(seen.has(keyu)) return;
    seen.add(keyu);
    addOrUpdateMessageToCache(meN, otherN, m);
  }

  try { const outRows = await apiList(otherN); for(const r of outRows) pushRowFromServer(r); } catch(e){ console.warn("LIST outgoing failed for", otherN, e); }
  if(isValidTfid(meN)){ try { const inRows = await apiList(meN); for(const r of inRows) pushRowFromServer(r); } catch(e){ console.warn("LIST incoming failed for", meN, e); } }
  renderConversation(meN, otherN);
}

/* ================== NOTIFICATIONS (permission, SW registration, show) ================== */
async function ensureNotificationSupportAndPermission(){
  // register SW if supported (makes notifications more reliable)
  if('serviceWorker' in navigator){
    try {
      await navigator.serviceWorker.register('/sw.js', { scope: '/' });
      console.log('Service worker registered');
    } catch(e){
      console.warn('SW register failed', e);
    }
  }
  if(!('Notification' in window)) return;
  if(Notification.permission === 'default'){
    try {
      const perm = await Notification.requestPermission();
      console.log('Notification permission', perm);
    } catch(e){ console.warn('notif perm request failed', e); }
  }
}
function showIncomingNotification(fromName, body, tag, data){
  try {
    if(navigator.serviceWorker && navigator.serviceWorker.getRegistration){
      navigator.serviceWorker.getRegistration().then(reg=>{
        if(reg && reg.showNotification){
          reg.showNotification(fromName || 'TF-Chat', { body: body || '', tag: tag || undefined, data: Object.assign({ url: '/' + encodeURIComponent(data?.from || '') }, data || {}), renotify: true });
          return;
        } else if(Notification.permission === 'granted'){
          new Notification(fromName || 'TF-Chat', { body: body || '', tag });
        }
      }).catch(err=>{ if(Notification.permission === 'granted') new Notification(fromName||'TF-Chat',{ body, tag }); });
    } else {
      if(Notification.permission === 'granted') new Notification(fromName||'TF-Chat',{ body, tag });
    }
  } catch(e){ console.warn('show notification failed', e); }
}

/* ================== WEBSOCKET + incoming handling (and call notifications) ================== */
function connectWS(){
  if(!me.tf17) return;
  try { ws = new WebSocket(WS_URL); } catch(e){ scheduleReconnect(); return; }
  ws.onopen = ()=>{ try{ ws.send(JSON.stringify({ type:'subscribe', tfid: me.tf17 })); }catch(e){} };
  ws.onmessage = (ev)=>{ try {
      const data = JSON.parse(ev.data);
      if(data.type === 'subscribed') return;
      if(data.type === 'message'){
        const payload = data;
        let parsed=null; try{ parsed = JSON.parse(payload.content); }catch(e){ parsed=null; }
        if(!parsed || !parsed.from) return;
        const recipientRaw = payload.tfid || null;
        const from = normParticipant(parsed.from);
        const recipient = normParticipant(recipientRaw);
        const other = (recipient === me.tf17) ? from : recipient;
        if(!other) return;
        // If read receipt
        if(parsed.type === 'read'){
          // mark messages as read
          const ck = convKey(me.tf17, other);
          const list = conversationCache[ck] || [];
          let changed=false;
          for(const it of list){
            if(it.from && normParticipant(it.from) === me.tf17){
              if(parsed.cid && it.cid && it.cid === parsed.cid){ if(!it.read){ it.read=true; changed=true; } }
              else if(parsed.id && it.id && String(it.id) === String(parsed.id)){ if(!it.read){ it.read=true; changed=true; } }
            }
          }
          if(changed) { saveConversationCacheForMe(); if(currentPartner && normParticipant(currentPartner.tf17) === other) renderConversation(me.tf17, other); }
          return;
        }
        // Normal incoming message: add to cache
        const created = parsed.time || payload.created_at || nowISO();
        const msgObj = { id: payload.id || null, cid: parsed.cid || null, from, text: parsed.text || parsed.message || '', parsed_time: parsed.time || null, _db_created_at: payload.created_at || null, created_at: created, read: false };
        addOrUpdateMessageToCache(me.tf17, other, msgObj);
        // update contacts UI
        if(parsed.name){ const c = ensureContactInList(other, parsed.name); c.name = parsed.name; c.lastMsg = msgObj.text; c.lastTs = Date.now(); saveState(); renderContacts(); }
        if(parsed.type === 'profile' && parsed.photo){ const c = ensureContactInList(other, parsed.name || null); c.avatar = parsed.photo; c.name = parsed.name || c.name; c.lastTs = Date.now(); saveState(); renderContacts(); }
        // if current open chat with that person, render; else increase unread + show notification
        if(currentPartner && normParticipant(currentPartner.tf17) === other){
          renderConversation(me.tf17, other);
          // when user opens chat we will mark read (handled in openChat)
        } else {
          const c = ensureContactInList(other, parsed && parsed.name ? parsed.name : null);
          c.unread = (c.unread||0) + 1; c.lastMsg = msgObj.text; c.lastTs = Date.now(); saveState(); renderContacts();
          // show push notification for last message
          showIncomingNotification(c.name || formatTFShort(other), (msgObj.text||'Nouveau message').slice(0,120), msgObj.cid || msgObj.id || undefined, {from: other});
        }
      }
  } catch(err){ console.warn('WS parse err', err); } };
  ws.onclose = ()=>{ scheduleReconnect(); };
  ws.onerror = (e)=>{ try{ ws.close(); }catch(e){} scheduleReconnect(); };
}
function scheduleReconnect(){ if(reconnectTimer) return; reconnectTimer = setTimeout(()=>{ reconnectTimer=null; connectWS(); }, 3000); }

/* ================== OPEN CHAT + SENDING + READ RECEIPT EMISSION ================== */
async function openChat(other17, contactObj=null, pushHistory=true){
  const otherN = normParticipant(other17);
  currentPartner = { tf17: otherN, name: (contactObj && contactObj.name) || null };
  chatTitleEl.textContent = (currentPartner.name || formatTFShort(currentPartner.tf17));
  const c = contacts.find(x => normParticipant(x.tf17) === otherN);
  if(c){ c.unread = 0; saveState(); renderContacts(); }
  messagesEl.innerHTML = '<div class="muted">Chaje mesaj...</div>';
  try { await loadConversation(me.tf17 || null, otherN); } catch(e){ messagesEl.innerHTML = `<div class="muted">Pa kapab chaje mesaj: ${escapeHtml(e.message||e)}</div>`; }
  showChatModal();
  // after loading conversation, send explicit read receipt for last incoming message
  try {
    const key = convKey(me.tf17, otherN);
    const arr = conversationCache[key] || [];
    // find last message from otherN
    let lastIncoming = null;
    for(let i=arr.length-1;i>=0;i--){
      if(normParticipant(arr[i].from) === otherN){ lastIncoming = arr[i]; break; }
    }
    if(lastIncoming){
      // send read receipt to otherN indicating we've read up to lastIncoming.cid or id
      const payload = { type:'read', from: me.tf17, time: nowISO(), cid: lastIncoming.cid || null, id: lastIncoming.id || null };
      // do not add as visible message locally; we just POST read
      await apiAdd(otherN, payload).catch(err=>{ console.warn('send read receipt failed', err); });
    }
    // also mark in local cache messages from otherN as read (so UI updates immediately)
    let changed=false;
    const list = conversationCache[convKey(me.tf17, otherN)] || [];
    for(const it of list){ if(normParticipant(it.from) === otherN && !it.read){ it.read = true; changed = true; } }
    if(changed) saveConversationCacheForMe();
    renderConversation(me.tf17, otherN);
  } catch(e){ console.warn('post-open read receipt failed', e); }
  // history push
  try {
    if(pushHistory){
      if(!history.state || !history.state._tfchat_init){ history.replaceState(Object.assign({}, history.state || {}, {_tfchat_init:true}), '', location.pathname); }
      history.pushState({tfchat: otherN}, '', '/' + encodeURIComponent(otherN));
    }
  } catch(e){}
}

function showChatModal(){ document.body.classList.add('chat-open'); chatModalEl.style.display = 'block'; setTimeout(()=> chatTextEl?.focus(), 150); }
function hideChatModal(){ chatModalEl.style.display = 'none'; document.body.classList.remove('chat-open'); currentPartner = null; currentGroup = null; }

async function sendMessageFromModal(){
  let txt = (chatTextEl?.value || '').trim(); if(!txt) return;
  if(!me.tf17){ alert('Ou dwe mete TFID nan Paramètres avan ou voye mesaj.'); return; }
  if(!currentPartner){ alert('Pa gen konvèsasyon chwazi.'); return; }
  const recipient17 = normParticipant(currentPartner.tf17);
  const cid = makeCid();
  const payload = { type:'text', from: me.tf17, text: txt, time: nowISO(), cid, name: me.name || null };
  // optimistic add
  addOrUpdateMessageToCache(me.tf17, recipient17, { id:null, cid, from: normParticipant(me.tf17), text: txt, created_at: payload.time, parsed_time: payload.time, _db_created_at: payload.time, _optimistic:true, read:false });
  renderConversation(me.tf17, recipient17);
  chatTextEl.value = '';
  // update contacts
  const c = contacts.find(x=> normParticipant(x.tf17) === recipient17);
  if(c){ c.lastMsg = txt; c.lastTs = Date.now(); saveState(); renderContacts(); }
  try {
    await apiAdd(recipient17, payload);
    startShortPollForMessage(recipient17, cid);
  } catch(e){ alert('Envoi echwe: ' + (e.message||e)); }
}

/* short poll to confirm message appears on server */
function startShortPollForMessage(target17, cid){ let tries = 0; const maxTries = 8; const interval = 1200; const attempt = async ()=>{ tries++; try{ const rows = await apiList(target17); const found = rows.find(r => { try{ const p = JSON.parse(r.content); return p && p.cid === cid; } catch(e){ return false; } }); if(found){ await loadConversation(me.tf17, target17); return true; } } catch(e){} if(tries < maxTries) setTimeout(attempt, interval); }; attempt(); }

/* ================== CONTACTS helpers ================== */
function ensureContactInList(tf17, name){
  const tfN = normParticipant(tf17);
  let c = contacts.find(x=> normParticipant(x.tf17) === tfN);
  if(!c){ c = { tf17: tfN, short: formatTFShort(tfN), name: name||null, unread:0, blocked:false, avatar:null, lastMsg:'', lastTs: Date.now() }; contacts.unshift(c); saveState(); renderContacts(); }
  return c;
}

/* ================== UI Events minimal binding ================== */
sendBtnEl?.addEventListener('click', sendMessageFromModal);
chatTextEl?.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendMessageFromModal(); } });

/* ================== BOOT: ensure notifications + ws ================== */
(async function boot(){
  renderContacts();
  renderGroups && renderGroups();
  if(me.tf17){
    loadConversationCacheForMe();
    await ensureNotificationSupportAndPermission();
    connectWS();
    fetchGroupsForMe && fetchGroupsForMe();
  } else {
    const shownOnce = localStorage.getItem('tfchat.settings_shown_once');
    if(!shownOnce) localStorage.setItem('tfchat.settings_shown_once','1');
  }
})();

/* expose debug */
window._tf_contacts = contacts;
window._tf_me = me;
window._tf_conv_cache = conversationCache;

/* minimal helpers */
function renderContacts(filter=''){ /* lightweight: original render function kept small for brevity */ const el = document.getElementById('contactsList'); if(!el) return; el.innerHTML = ''; if(contacts.length===0){ const d=document.createElement('div'); d.className='muted'; d.textContent='Pa gen kontak.'; el.appendChild(d); return; } contacts.forEach(c=>{ const item=document.createElement('div'); item.className='contact'; item.dataset.tf17=c.tf17||''; const avatarHtml = c.avatar ? `<img src="${c.avatar}" />` : escapeHtml((c.name||formatTFShort(c.tf17)||'').slice(0,2)); item.innerHTML = `<div class="avatar">${avatarHtml}</div><div class="meta"><div class="meta-top"><div class="name">${escapeHtml(c.name||formatTFShort(c.tf17)||'')}</div><div class="time">${c.lastTs? timeAgo(c.lastTs):''}</div></div><div class="meta-bottom"><div class="snippet">${escapeHtml(c.lastMsg||'')}</div><div>${c.unread?'<span class="badge">'+c.unread+'</span>':''}</div></div></div>`; item.addEventListener('click', ()=> openChat(c.tf17, c, true)); el.appendChild(item); }); }
function renderGroups(){ /* noop or keep original if exists */ }
function timeAgo(ts){ if(!ts) return ''; const diff=Math.floor((Date.now()-ts)/1000); if(diff<60) return diff+'s'; if(diff<3600) return Math.floor(diff/60)+'m'; if(diff<86400) return Math.floor(diff/3600)+'h'; return new Date(ts).toLocaleDateString(); }
function messageUniqueKey(m){ if(m.cid) return "cid:"+m.cid; if(m.id) return "id:"+m.id; return "temp:"+ (m._tempKey || (m._tempKey = Math.random().toString(36).slice(2))); }
async function fetchGroupsForMe(){ /* noop if not needed */ return []; }

/* tiny helpers used for profile/save previously referenced in other code paths */
function getPasswordHash(tf17){ return localStorage.getItem(`tfchat.pw.${tf17}`); }
function initials(name){ if(!name) return 'U'; return name.split(' ').map(p=>p[0]).slice(0,2).join('').toUpperCase(); }
async function uploadFileToProfile(file){ const fd = new FormData(); fd.append('file', file); const resp = await fetch(PROFILE_UPLOAD_URL, { method:'POST', body: fd }); const text = await resp.text().catch(()=>null); let json = null; try{ json = JSON.parse(text); }catch(e){} if(!resp.ok || !json || !(json.ok || json.success) || !(json.url || json.path)) { const msg = json?.error || text || `status ${resp.status}`; throw new Error('Upload failed: ' + msg); } return json.url || json.path; }

</script>
</body>
  </html>
