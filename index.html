<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TF-Chat</title>
  <style>
    /* --- minimal styles (kenbe sa ou te genyen si gen lòt CSS) --- */
    body { font-family: system-ui, Arial; margin:0; padding:0; background:#f7f7f8; color:#111; }
    .header { display:flex; align-items:center; gap:12px; padding:12px 16px; background:#fff; border-bottom:1px solid #eee; }
    .app-logo { width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:linear-gradient(90deg,#4f46e5,#06b6d4); color:white; font-weight:700; }
    .app-title { font-size:18px; font-weight:600; cursor:pointer; display:flex; align-items:center; gap:8px; }
    .main { display:flex; gap:12px; padding:16px; }
    /* chat area */
    #chatModal { width:100%; max-width:900px; margin:0 auto; background:#fff; border-radius:8px; box-shadow:0 4px 18px rgba(0,0,0,0.06); padding:12px; }
    #messages { max-height:60vh; overflow:auto; padding:8px; }
    .message-row { padding:6px 8px; margin:6px 0; border-radius:8px; background:#f2f4f7; }
    .compose { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .compose textarea { flex:1; min-height:44px; padding:8px; border-radius:8px; border:1px solid #ddd; resize:vertical;}
    .btn { display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; border-radius:8px; border:none; background:#2563eb; color:white; cursor:pointer; }
    .icon-btn { width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:#2563eb; color:white; border:none; cursor:pointer; }
    .small-muted { color:#666; font-size:12px; }
  </style>
</head>
<body>

  <header class="header">
    <div class="app-logo" aria-hidden="true">TF</div>
    <div class="app-title" title="Paramètres & profil">
      <!-- replaced bell emoji by a small SVG notification icon to look professional -->
      <span style="display:inline-flex;align-items:center;gap:8px;">
        TF-Sove
        <svg id="notifLogo" width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M15 17h5l-1.405-1.405A2.032 2.032 0 0 1 18.6 14.6V11a6.002 6.002 0 0 0-4-5.659V4a2 2 0 1 0-4 0v1.341C8.4 6.165 6 8.388 6 11v3.6c0 .538-.214 1.055-.595 1.435L4 17h11z" stroke="#0f172a" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"></path>
          <path d="M13.73 21a2 2 0 0 1-3.46 0" stroke="#0f172a" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </span>
    </div>
    <div style="margin-left:auto; display:flex; gap:12px; align-items:center;">
      <div id="wsStatus" class="small-muted">WS: —</div>
      <button id="openSettingsBtn" class="btn">Settings</button>
    </div>
  </header>

  <main class="main">
    <section style="flex:1;">
      <div id="chatModal">
        <div id="messages" aria-live="polite"></div>

        <div class="compose" id="chatInputRow">
          <textarea id="chatText" placeholder="Écrire un message..."></textarea>

          <!-- Send button: real SVG icon (no emoji or plain text) -->
          <button id="sendBtn" class="icon-btn" title="Envoyer" aria-label="Envoyer">
            <!-- modern rounded send icon -->
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M22 2L11 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="white" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" fill="white" opacity="0.08"/>
            </svg>
          </button>
        </div>
      </div>
    </section>
  </main>

  <!-- Settings modal / small UI pieces should be here (omitted for brevity if you have full UI) -->
  <!-- ... keep your full modals and other markup as before ... -->

<script>
/* ================== CONFIG (adjust if needed) ================== */
/* Link client to your server base */
const API_BASE = 'https://tf-sove.onrender.com'; // <--- server url (as requested)
const FRONTEND_NAME = 'site1'; // change if needed (must match registered frontend on server)
const SUBSCRIBE_ENDPOINT = API_BASE + '/push/subscribe'; // server endpoint we implemented
const VAPID_GET_ENDPOINT = API_BASE + '/push/vapid'; // server endpoint to fetch public key
let VAPID_PUBLIC_KEY = null; // will be fetched at boot

/* ================== App state (keep original logic) ================== */
let me = { tf17: localStorage.getItem('tfchat.me.17') || '', name: localStorage.getItem('tfchat.me.name') || '', short: localStorage.getItem('tfchat.me.short') || '', avatarDataUrl: localStorage.getItem('tfchat.me.avatar') || '' };
let ws = null;
let reconnectTimer = null;

/* DOM refs */
const messagesEl = document.getElementById('messages');
const chatTextEl = document.getElementById('chatText');
const sendBtnEl = document.getElementById('sendBtn');
const wsStatusEl = document.getElementById('wsStatus');
const appTitleEl = document.querySelector('.app-title');
const openSettingsBtn = document.getElementById('openSettingsBtn');

/* ------------------ Helper: format message in UI ------------------ */
function appendMessageRow(msgObj, opts = {}) {
  // msgObj: {id, tfid, content, created_at, name}
  const row = document.createElement('div');
  row.className = 'message-row';
  const who = document.createElement('div');
  who.innerHTML = `<strong>${escapeHtml(msgObj.name || msgObj.from || msgObj.tfid)}</strong> <span class="small-muted">${msgObj.created_at ? new Date(msgObj.created_at).toLocaleString() : ''}</span>`;
  const body = document.createElement('div');
  let text = '';
  try {
    const p = JSON.parse(msgObj.content);
    text = p.text || p.message || JSON.stringify(p);
  } catch (e) {
    text = msgObj.content || '';
  }
  body.textContent = text;
  row.appendChild(who);
  row.appendChild(body);
  messagesEl.appendChild(row);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* escapeHtml copied from server for safety */
function escapeHtml(s) {
  if (s == null) return "";
  return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}

/* ------------------ API helpers ------------------ */
async function apiAdd(tfid, payload) {
  const url = API_BASE + '/api/add';
  const body = Object.assign({}, payload);
  // body must include 'name' (frontend name) and 'tfid' or 'group_name'
  if(!body.tfid) body.tfid = tfid;
  body.name = FRONTEND_NAME;
  try {
    const r = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body) });
    return await r.json();
  } catch (e) { throw e; }
}

async function apiList(tfid) {
  const url = API_BASE + '/api/list?tfid=' + encodeURIComponent(tfid) + '&name=' + encodeURIComponent(FRONTEND_NAME);
  const r = await fetch(url);
  const j = await r.json();
  if(!j.ok) throw new Error(j.error || 'api list failed');
  return j.rows || [];
}

/* ------------------ WebSocket (subscribe + rehydrate) ------------------ */
function connectWS() {
  if (!me.tf17) {
    wsStatusEl.textContent = 'WS: no profile';
    return;
  }
  const wsUrl = (API_BASE.replace(/^http/, 'ws')) + '/ws';
  try {
    ws = new WebSocket(wsUrl);
  } catch (e) {
    wsStatusEl.textContent = 'WS: error';
    scheduleReconnect();
    return;
  }
  ws.onopen = () => {
    wsStatusEl.textContent = 'WS: open';
    // subscribe our TFID
    try { ws.send(JSON.stringify({ type: 'subscribe', tfid: me.tf17 })); } catch(e){}
    // also fetch recent messages via API to ensure UI rehydrates
    loadConversationCacheForMe().catch(()=>{});
  };
  ws.onmessage = (ev) => {
    try {
      const d = JSON.parse(ev.data);
      if(d && d.type === 'message') {
        appendMessageRow(d);
        // show a local notification as well
        showNotificationForIncoming(d);
      }
    } catch(e){ console.warn('ws parse error', e); }
  };
  ws.onclose = () => { wsStatusEl.textContent = 'WS: closed'; scheduleReconnect(); };
  ws.onerror = (e) => { wsStatusEl.textContent = 'WS: error'; console.warn('ws err', e); scheduleReconnect(); };
}

function scheduleReconnect() {
  if (reconnectTimer) return;
  reconnectTimer = setTimeout(()=>{ reconnectTimer = null; connectWS(); }, 3000 + Math.floor(Math.random()*3000));
}

async function loadConversationCacheForMe() {
  if (!me.tf17) return;
  try {
    const rows = await apiList(me.tf17);
    messagesEl.innerHTML = ''; // clear and render
    for (let r of rows.reverse()) {
      appendMessageRow(r);
    }
  } catch (e) {
    console.warn('rehydrate failed', e);
  }
}

/* ------------------ Sending messages ------------------ */
async function sendMessageFromModal() {
  const text = (chatTextEl.value || '').trim();
  if(!text) return;
  const payload = { content: text, content_type: 'text', from: me.tf17 || null };
  try {
    // deliver to current open partner or just store
    // for demo: assume you have currentPartner variable; else you can hardcode recipient (example)
    const toTfid = window.currentPartner ? window.currentPartner.tf17 : null;
    if(!toTfid) { alert('Ouvrir yon chat an premye'); return; }
    const r = await apiAdd(toTfid, payload);
    if (r && r.ok) {
      chatTextEl.value = '';
      // append locally right away (server will also broadcast back)
      appendMessageRow({ name: me.name || me.tf17, content: JSON.stringify({ text }), created_at: new Date().toISOString(), tfid: toTfid });
    } else {
      alert('Échec envoi: ' + (r && r.error) );
    }
  } catch (e) {
    alert('Erreur envoi: ' + e.message);
  }
}

/* ------------------ Push subscription helpers ------------------ */
function urlBase64ToUint8Array(base64String) {
  // convert VAPID key for subscribe
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
  return outputArray;
}

async function fetchVapidPublicKey() {
  try {
    const r = await fetch(VAPID_GET_ENDPOINT);
    const j = await r.json();
    if (j && j.ok && j.publicKey) {
      VAPID_PUBLIC_KEY = j.publicKey;
      return VAPID_PUBLIC_KEY;
    } else {
      console.warn('vapid key not available', j);
      return null;
    }
  } catch (e) { console.warn('fetchVapidPublicKey err', e); return null; }
}

async function askNotificationPermissionAndSubscribe() {
  if (!('serviceWorker' in navigator)) return;
  // register service worker (if not yet)
  try {
    const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
    console.log('sw registered', reg);
  } catch (e) {
    console.warn('sw register failed', e);
  }
  // fetch vapid key from server
  await fetchVapidPublicKey();
  if (!VAPID_PUBLIC_KEY) {
    console.warn('no vapid key; cannot subscribe');
    return;
  }

  // request permission
  if (Notification.permission === 'default') {
    try { await Notification.requestPermission(); } catch(e){}
  }
  if (Notification.permission !== 'granted') {
    console.warn('Notifications not granted');
    return;
  }
  // do subscription
  try {
    const reg = await navigator.serviceWorker.ready;
    // try to reuse existing subscription
    let sub = await reg.pushManager.getSubscription();
    if (!sub) {
      sub = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
      });
    }
    // send to server
    if (sub && me.tf17) {
      await fetch(SUBSCRIBE_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tfid: me.tf17, subscription: sub })
      });
      console.log('push subscription saved to server');
    } else {
      console.warn('no subscription or no me.tf17');
    }
  } catch (e) {
    console.warn('subscribe failed', e);
  }
}

/* small helper: send WAKE push when incoming message arrives (server already attempts) */
function showNotificationForIncoming(payload) {
  // if page visible, optional: show in-UI; else show notification
  const title = (payload.name && payload.name !== '') ? payload.name : 'TF-Chat';
  const body = (typeof payload.content === 'string' ? (payload.content.length>200?payload.content.slice(0,200)+'...':payload.content) : '');
  const data = payload;
  // page visibility
  if (document.visibilityState === 'visible') {
    // optionally flash UI
    try { navigator.vibrate && navigator.vibrate(100); } catch(e){}
    return;
  }
  // otherwise trigger a notification via service worker
  if (navigator.serviceWorker && navigator.serviceWorker.controller) {
    navigator.serviceWorker.controller.postMessage({ cmd: 'show-notif', title, body, data });
  } else {
    // fallback: use Notification API directly
    if (Notification.permission === 'granted') {
      new Notification(title, { body, data, icon: '/images/notification-128.png', badge: '/images/notification-badge.png' });
    }
  }
}

/* ------------------ Service Worker message relay (optional) ------------------ */
navigator.serviceWorker?.addEventListener?.('message', (ev) => {
  // handle messages from sw if needed
  // console.log('from-sw', ev.data);
});

/* ------------------ Boot logic ------------------ */
(async function boot(){
  // render existing cached messages if any
  if (me.tf17) {
    try { await loadConversationCacheForMe(); } catch(e){ console.warn(e); }
  }
  // register WS
  connectWS();
  // register service worker and subscribe (if possible)
  // do not block boot if vapid not available
  try { await askNotificationPermissionAndSubscribe(); } catch(e){ console.warn(e); }

  // wire send button
  sendBtnEl.addEventListener('click', sendMessageFromModal);
  chatTextEl.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter' && !ev.shiftKey){ ev.preventDefault(); sendMessageFromModal(); } });

  // settings button open (or title click)
  openSettingsBtn?.addEventListener('click', ()=>{ // open your settings modal (existing HTML) if present
    // existing logic probably toggles #settingsModal
    // fallback alert:
    if(typeof updateSettingsUI === 'function'){ updateSettingsUI(); document.getElementById('settingsModal').style.display = 'flex'; } else { alert('Open settings'); }
  });

  // ensure WS reconnect on visibility change if needed
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      // rehydrate messages & reconnect ws
      if (!ws || ws.readyState !== WebSocket.OPEN) connectWS();
      loadConversationCacheForMe().catch(()=>{});
    }
  });
})();
</script>

</body>
  </html>
