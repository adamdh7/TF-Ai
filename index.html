<!doctype html>
<html lang="ht">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>TF-Chat</title>

<link rel="manifest" href="/manifest.json">
<link rel="icon" type="image/jpeg" href="https://files.catbox.moe/ixgmht.jpg" />
<link rel="apple-touch-icon" href="https://files.catbox.moe/ixgmht.jpg" />
<meta name="theme-color" content="#000000">

<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#000000; --panel:#000000; --text:#e6eefb; --muted:#9aa6bf;
  --card:#0b0b0b; --accent:#0b81ff; --header-h:56px; --tab-h:62px;
  --msg-line-height:1.35rem; --msg-max-lines:8;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Roboto,system-ui,Arial,sans-serif;-webkit-font-smoothing:antialiased}
header{position:fixed;left:0;right:0;top:0;height:var(--header-h);display:flex;align-items:center;justify-content:center;background:var(--panel);z-index:1000;border-bottom:1px solid rgba(255,255,255,0.03)}
.app-title{font-weight:700;font-size:18px;cursor:pointer}
main{position:fixed;left:0;right:0;top:var(--header-h);bottom:var(--tab-h);overflow:auto;padding:12px;margin:0 auto;max-width:980px}
body.chat-open main > section { display:none !important; }
.tabbar { position:fixed; left:0; right:0; bottom:0; height:var(--tab-h); display:flex; gap:0; border-top:1px solid rgba(255,255,255,0.03); background:var(--panel); align-items:center; justify-content:center; z-index:1000; }
.tab { flex:1; text-align:center; padding:10px 6px; cursor:pointer; font-weight:700; color:var(--muted); }
.tab.active{ color:var(--text); border-top:3px solid var(--accent); background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }
.search{padding:8px 12px;display:flex;justify-content:center}
.search-box{display:flex;align-items:center;gap:8px;background:var(--card);padding:10px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);width:100%;max-width:980px}
.search-box input{flex:1;background:transparent;border:0;outline:none;color:var(--text);font-size:15px}
.search-btn{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
.list{margin-top:12px}
.contact{display:flex;gap:12px;align-items:center;padding:12px;border-radius:12px;cursor:pointer;width:100%}
.contact:hover{background:rgba(255,255,255,0.02)}
.avatar{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));display:inline-flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;color:var(--text);flex-shrink:0;overflow:hidden}
.avatar img{width:100%;height:100%;object-fit:cover;border-radius:50%}
.meta{flex:1;min-width:0}
.meta-top{display:flex;justify-content:space-between;align-items:flex-start}
.name{font-weight:600;font-size:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.time{font-size:12px;color:var(--muted)}
.meta-bottom{display:flex;justify-content:space-between;margin-top:6px;align-items:center}
.snippet{font-size:13px;color:var(--muted);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.badge{background:var(--accent);color:white;padding:4px 8px;border-radius:999px;font-weight:600;font-size:13px}
.messages-wrap{padding:12px;height:calc(100% - 56px - 84px);overflow:auto;display:flex;flex-direction:column;gap:8px}
.messages{display:flex;flex-direction:column;gap:8px}
.msg{max-width:74%;padding:10px;border-radius:12px;margin-bottom:4px;word-break:break-word;overflow:hidden;display:inline-block}
.msg.bot{background:#121212;color:var(--text);align-self:flex-start}
.msg.user{background:linear-gradient(180deg,var(--accent),#0563c9);color:white;align-self:flex-end}
.msg .checks{font-size:11px;margin-left:8px;opacity:0.9}
.msg .checks.read{opacity:1;font-weight:700}
.msg-text{ white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; display:block; line-height: var(--msg-line-height); max-height: calc(var(--msg-line-height) * var(--msg-max-lines)); }
.msg-meta{font-size:11px;color:var(--muted);margin-top:6px;display:flex;gap:8px;align-items:center}
.chat-input{display:flex;gap:8px;align-items:center;padding:12px;border-top:1px solid rgba(255,255,255,0.03);background:transparent}
.input{flex:1;padding:12px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);background:var(--card);color:var(--text);outline:none;min-width:0}
.send-btn{background:transparent;border:0;padding:8px;border-radius:10px;cursor:pointer;color:var(--accent);display:inline-flex;align-items:center;justify-content:center}
.muted{text-align:center;color:var(--muted);padding:20px}
@media (min-width:900px){main{max-width:700px;margin:0 auto}}
</style>
</head>
<body>
  <header><div class="app-title" id="appTitle">TF-Chat</div></header>

  <main>
    <section id="section-accueil">
      <section class="search">
        <div class="search-box" role="search">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" aria-hidden="true"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6"/><circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.6"/></svg>
          <input id="searchInput" placeholder="Recherche (TFID ou 7 chif)" aria-label="Recherche" />
          <button id="searchBtn" class="search-btn">Rechercher</button>
        </div>
      </section>

      <section class="list" id="contactsList" aria-live="polite"></section>
    </section>
  </main>

  <div class="tabbar">
    <div id="tabAccueil" class="tab active">Accueil</div>
    <div id="tabGroupes" class="tab">Groupes</div>
  </div>

  <!-- Chat modal -->
  <div id="chatModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.96);z-index:1200">
    <div style="height:100%;display:flex;flex-direction:column">
      <div style="height:56px;display:flex;align-items:center;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.03)">
        <button id="chatBack" style="background:transparent;border:0;color:var(--text);cursor:pointer">‚Üê</button>
        <div style="flex:1;text-align:center;font-weight:700;cursor:pointer" id="chatTitle">Chat</div>
        <div style="width:44px"></div>
      </div>
      <div class="messages-wrap">
        <div class="messages" id="messages" aria-live="polite" role="log"></div>
      </div>
      <div class="chat-input" id="chatInputRow">
        <input id="chatText" class="input" placeholder="Ekri mesaj..." autocomplete="off" />
        <button id="sendBtn" class="send-btn" aria-label="Envoyer" title="Envoyer">
          <!-- send SVG icon (real icon, not emoji) -->
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M2 21L23 12 2 3v7l15 2-15 2v7z" fill="currentColor"/></svg>
        </button>
      </div>
    </div>
  </div>

<script>
/* ================== CONFIG ================== */
const API_BASE = 'https://tf-sove.onrender.com';
const PUSH_VAPID_ENDPOINT = API_BASE + '/push/vapid';
const PUSH_SUBSCRIBE_ENDPOINT = API_BASE + '/push/subscribe';
const PROFILE_UPLOAD_URL = API_BASE + '/upload';
const FRONTEND_NAME = 'site1';
const WS_HOST = 'tf-sove.onrender.com';
const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + WS_HOST + "/ws";

/* Notification icon paths (make sure these files exist on server) */
const NOTIF_ICON = '/images/notification-128.png';
const NOTIF_BADGE = '/images/notification-badge.png';

/* ================== HELPERS ================== */
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function normalizeInputToDigits(inp){ if(!inp) return null; const s=String(inp).trim().toUpperCase(); const digits=s.replace(/[^0-9]/g,''); return digits||null; }
function to17(shortOrDigits){ if(!shortOrDigits) return null; const ds=String(shortOrDigits).replace(/[^0-9]/g,''); if(ds.length>17) return ds.slice(-17); return ds.padStart(17,'0'); }
function formatTFShort(digitsString){ if(!digitsString) return ''; const s=String(digitsString).replace(/[^0-9]/g,''), last7=s.slice(-7); return 'TF-'+ last7.padStart(7,'0'); }
function nowISO(){ return (new Date()).toISOString(); }
function makeCid(){ return String(Date.now()) + '-' + Math.floor(Math.random()*100000).toString(16); }
function isValidTfid(tfid){ return typeof tfid === 'string' && /^\d{17}$/.test(tfid); }
function timeAgo(ts){ if(!ts) return ''; const diff=Math.floor((Date.now()-ts)/1000); if(diff<60) return diff+'s'; if(diff<3600) return Math.floor(diff/60)+'m'; if(diff<86400) return Math.floor(diff/3600)+'h'; return new Date(ts).toLocaleDateString(); }

/* ================== STATE ================== */
let me = {
  short: localStorage.getItem('tfchat.me.short') || null,
  tf17: localStorage.getItem('tfchat.me.17') || null,
  name: localStorage.getItem('tfchat.me.name') || 'Utilisateur',
  avatarDataUrl: localStorage.getItem('tfchat.me.avatar') || null
};
if(me.tf17) me.tf17 = me.tf17.replace(/\s+/g,'');

let contacts = JSON.parse(localStorage.getItem('tfchat.contacts') || '[]') || [];
let groups = JSON.parse(localStorage.getItem('tfchat.groups') || '[]') || [];
let conversationCache = {}; // will persist per-me when setIdentity

/* Persist/load conv per identity */
function convStorageKeyForMe(tf17){ return `tfchat.conv.${(tf17||'anon')}`; }
function saveConversationCacheForMe(){ if(!me.tf17) return; try{ localStorage.setItem(convStorageKeyForMe(me.tf17), JSON.stringify(conversationCache || {})); }catch(e){console.warn('save conv fail',e);} }
function loadConversationCacheForMe(){ if(!me.tf17) return; try{ const raw = localStorage.getItem(convStorageKeyForMe(me.tf17)); if(raw) conversationCache = JSON.parse(raw); }catch(e){conversationCache={};} }

/* ================== SERVICE WORKER & PUSH ================== */
async function ensureSW(){
  if(!('serviceWorker' in navigator)) return null;
  try {
    const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
    console.log('SW registered', reg.scope);
    return reg;
  } catch(e){
    console.warn('SW register failed', e);
    return null;
  }
}

function urlBase64ToUint8Array(base64String){
  if(!base64String) return null;
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
  return outputArray;
}

async function fetchVapidPublicKey(){
  try {
    const r = await fetch(PUSH_VAPID_ENDPOINT);
    if(!r.ok) return '';
    const j = await r.json().catch(()=>null);
    return j && j.publicKey ? j.publicKey : '';
  } catch(e){ return ''; }
}

async function subscribePushIfAllowed(){
  if(!('serviceWorker' in navigator) || !('PushManager' in window)) return false;
  if(!me.tf17) return false; // need identity
  let perm = Notification.permission;
  if(perm !== 'granted') perm = await Notification.requestPermission();
  if(perm !== 'granted') return false;
  const reg = await ensureSW();
  if(!reg) return false;
  const publicKey = await fetchVapidPublicKey();
  if(!publicKey) { console.warn('VAPID public key not available'); return false; }
  try {
    const sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(publicKey) });
    const body = { tfid: me.tf17, subscription: sub };
    const r = await fetch(PUSH_SUBSCRIBE_ENDPOINT, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    if(!r.ok) { console.warn('subscribe endpoint failed', await r.text().catch(()=>'')); return false; }
    localStorage.setItem('tfchat.push.subscribed', '1');
    console.log('Push subscription saved.');
    return true;
  } catch(e){ console.warn('subscribePush failed', e); return false; }
}

/* show local (immediate) notification via SW when page hidden */
async function showLocalNotification(title, body, data = {}){
  try {
    if('serviceWorker' in navigator) {
      const reg = await navigator.serviceWorker.ready;
      reg.showNotification(title, { body, icon: NOTIF_ICON, badge: NOTIF_BADGE, data, renotify:true, vibrate:[100,50,100] });
      return;
    }
    if(Notification.permission === 'granted') new Notification(title, { body, icon: NOTIF_ICON, data });
  } catch(e){ console.warn('showLocalNotification err', e); }
}

/* ================== UI RENDER ================== */
const contactsListEl = document.getElementById('contactsList');
const messagesEl = document.getElementById('messages');
const chatModalEl = document.getElementById('chatModal');
const chatTitleEl = document.getElementById('chatTitle');
const chatTextEl = document.getElementById('chatText');
const sendBtnEl = document.getElementById('sendBtn');

function renderContacts(filter=''){
  contactsListEl.innerHTML = '';
  const q = (filter||'').toLowerCase().trim();
  const list = contacts.filter(c => { if(!q) return true; return (c.name||'').toLowerCase().includes(q) || (c.tf17||'').toLowerCase().includes(q); });
  if(list.length === 0){
    const div = document.createElement('div'); div.className='muted'; div.textContent='Pa gen kontak. Rech√®ch yon TFID oswa ajoute yon kontak.'; contactsListEl.appendChild(div); return;
  }
  list.forEach(c => {
    const el = document.createElement('div'); el.className='contact'; el.dataset.tf17 = c.tf17 || '';
    const avatarHtml = c.avatar ? `<img src="${c.avatar}" />` : escapeHtml((c.name||formatTFShort(c.tf17) || '').slice(0,2));
    el.innerHTML = `<div class="avatar">${avatarHtml}</div>
      <div class="meta">
        <div class="meta-top">
          <div class="name">${escapeHtml(c.name||formatTFShort(c.tf17)||'')}</div>
          <div class="time">${c.lastTs? timeAgo(c.lastTs): ''}</div>
        </div>
        <div class="meta-bottom">
          <div class="snippet">${escapeHtml(c.lastMsg||'')}</div>
          <div>${c.unread?'<span class="badge">'+c.unread+'</span>':''}</div>
        </div>
      </div>`;
    el.addEventListener('click', ()=> { openChat(c.tf17, c, true); });
    contactsListEl.appendChild(el);
  });
}

function renderConversation(me17, other17){
  const key = `${me17}|${other7abled? other17:other17}`.replace(/undefined/g,'');
  const arr = (conversationCache[`${me17}|${other17}`] || []).slice();
  arr.sort((a,b) => new Date(a.created_at || a._db_created_at || 0) - new Date(b.created_at || b._db_created_at || 0));
  messagesEl.innerHTML = '';
  if(arr.length === 0){ const d=document.createElement('div'); d.className='muted'; d.textContent='Pa gen mesaj ank√≤.'; messagesEl.appendChild(d); return; }
  arr.forEach(m=>{
    const isMe = (m.from === me17);
    const d = document.createElement('div'); d.className='msg '+(isMe?'user':'bot');
    const textBlock = document.createElement('div'); textBlock.className='msg-text'; textBlock.appendChild(document.createTextNode(m.text || m.content || ''));
    const meta = document.createElement('div'); meta.className='msg-meta'; const ts = m.created_at ? (new Date(m.created_at)).toLocaleString() : '';
    const checksEl = document.createElement('span'); checksEl.style.marginLeft='8px'; checksEl.className='checks' + ((isMe && m._read)?' read':'');
    if(isMe){ checksEl.textContent = m._read ? '‚úì‚úì' : (m.id ? '‚úì‚úì' : '‚úì'); }
    meta.textContent = `${formatTFShort(m.from||'')} ‚Ä¢ ${ts} `;
    meta.appendChild(checksEl);
    d.appendChild(textBlock); d.appendChild(meta); messagesEl.appendChild(d);
  });
  setTimeout(()=>{ const wrap=document.querySelector('#chatModal .messages-wrap'); if(wrap) wrap.scrollTop = wrap.scrollHeight; }, 40);
}

/* ================== CONV CACHE helpers ================== */
function ensureConversationArray(a,b){
  if(!a || !b) return [];
  const k = `${a}|${b}`;
  if(!conversationCache[k]) conversationCache[k] = [];
  return conversationCache[k];
}
function addOrUpdateMessageToCache(me17, other17, msg){
  if(!me17 || !other17) return;
  const k1 = `${me17}|${other17}`; const k2 = `${other17}|${me17}`;
  // always store under canonical key where me is first arg for consistency
  const arr = ensureConversationArray(me17, other17);
  const idx = msg.cid ? arr.findIndex(x=>x.cid===msg.cid) : (msg.id ? arr.findIndex(x=>x.id && String(x.id) === String(msg.id)) : -1);
  if(idx !== -1) arr[idx] = Object.assign({}, arr[idx], msg); else arr.push(msg);
  arr.sort((a,b)=> new Date(a.created_at || a._db_created_at || 0) - new Date(b.created_at || b._db_created_at || 0));
  saveConversationCacheForMe();
}

/* ================== LOAD / SYNC conversation ================== */
async function loadConversation(me17, other17){
  if(!me17 || !other17) return;
  try {
    // outgoing: messages where other is the "sender" (we use server /api/list to get rows for that person)
    const out = await fetch(`${API_BASE}/api/list?tfid=${encodeURIComponent(other17)}&name=${encodeURIComponent(FRONTEND_NAME)}`);
    if(out.ok){
      const j = await out.json().catch(()=>null);
      if(j && Array.isArray(j.rows)){
        for(const r of j.rows){
          let parsed=null;
          try{ parsed = JSON.parse(r.content); }catch(e){ parsed = null; }
          const from = parsed && parsed.from ? parsed.from : null;
          if(!from) continue;
          const text = parsed && (parsed.text||parsed.message) ? parsed.text||parsed.message : r.content;
          addOrUpdateMessageToCache(me17, other17, { id: r.id, cid: parsed && parsed.cid ? parsed.cid : null, from, text, created_at: parsed?.time || r.created_at || nowISO(), _db_created_at: r.created_at });
        }
      }
    }
    // incoming: messages where me is recipient
    const inc = await fetch(`${API_BASE}/api/list?tfid=${encodeURIComponent(me17)}&name=${encodeURIComponent(FRONTEND_NAME)}`);
    if(inc.ok){
      const j2 = await inc.json().catch(()=>null);
      if(j2 && Array.isArray(j2.rows)){
        for(const r of j2.rows){
          let parsed=null;
          try{ parsed = JSON.parse(r.content); }catch(e){ parsed = null; }
          const from = parsed && parsed.from ? parsed.from : null;
          if(!from) continue;
          const text = parsed && (parsed.text||parsed.message) ? parsed.text||parsed.message : r.content;
          // only add messages that belong to this conversation (from the other)
          if(from === other17 || from === me17) {
            addOrUpdateMessageToCache(me17, other17, { id: r.id, cid: parsed && parsed.cid ? parsed.cid : null, from, text, created_at: parsed?.time || r.created_at || nowISO(), _db_created_at: r.created_at });
          }
        }
      }
    }
    renderConversation(me17, other17);
  } catch(e){
    console.warn('loadConversation error', e);
  }
}

/* ================== WS client (reconnect + resync) ================== */
let ws = null, reconnectTimer = null, currentPartner = null;
function connectWS(){
  if(!me.tf17) return;
  try { ws = new WebSocket(WS_URL); } catch(e){ scheduleReconnect(); return; }
  ws.onopen = async ()=> {
    try{ ws.send(JSON.stringify({ type:'subscribe', tfid: me.tf17 })); }catch(e){}
    // on reconnect resync unread convs
    contacts.filter(c=>c.unread).forEach(c=> loadConversation(me.tf17, c.tf17));
    // auto push subscribe if needed
    if(Notification.permission === 'granted' && !localStorage.getItem('tfchat.push.subscribed')) await subscribePushIfAllowed().catch(()=>{});
  };
  ws.onmessage = async (ev) => {
    try {
      const data = JSON.parse(ev.data);
      if(data.type === 'subscribed') return;
      if(data.type === 'message'){
        let parsed=null;
        try{ parsed = (typeof data.content === 'string') ? JSON.parse(data.content) : data.content; }catch(e){ parsed = data.content || {}; }
        const from = parsed && parsed.from ? parsed.from : (data.from || null);
        if(!from) return;
        const other = (data.tfid === me.tf17) ? from : (data.tfid || from);
        const created_at = parsed && parsed.time ? parsed.time : (data.created_at || nowISO());
        const text = parsed && (parsed.text||parsed.message) ? parsed.text||parsed.message : (data.content || '');
        const msgObj = { id: data.id || null, cid: parsed && parsed.cid ? parsed.cid : null, from, text, created_at, _db_created_at: data.created_at || null };
        addOrUpdateMessageToCache(me.tf17, other, msgObj);

        if(currentPartner && currentPartner.tf17 === other){
          // open chat visible -> render + send read receipt
          renderConversation(me.tf17, other);
          markAsReadAndNotifySender(other, nowISO()).catch(()=>{});
        } else {
          // not in chat -> unread + local notification if hidden
          let c = contacts.find(x=>x.tf17===other);
          if(!c){
            c = { tf17: other, name: parsed && parsed.name ? parsed.name : formatTFShort(other), unread:0, lastMsg:'', lastTs: Date.now(), avatar:null };
            contacts.unshift(c);
          }
          c.unread = (c.unread||0) + 1;
          c.lastMsg = text;
          c.lastTs = Date.now();
          saveState();
          renderContacts();
          if(document.hidden || !document.hasFocus()){
            const title = (parsed && parsed.name) ? parsed.name : formatTFShort(other);
            await showLocalNotification(title, (text||'Nouveau message'), { tfid: other, messageId: data.id });
          }
        }
      }
      // treat read receipts
      if(data.type === 'message'){
        try {
          const p2 = (typeof data.content === 'string') ? JSON.parse(data.content) : data.content;
          if(p2 && p2.type === 'read' && p2.from && p2.ref_time){
            const reader = p2.from;
            const k = `${me.tf17}|${reader}`;
            const arr = conversationCache[k] || [];
            let changed=false; const cutoff = p2.ref_time ? Date.parse(p2.ref_time) : Date.now();
            arr.forEach(m=>{ const t = m.created_at ? Date.parse(m.created_at) : 0; if(t<=cutoff && m.from===me.tf17 && !m._read){ m._read=true; changed=true; }});
            if(changed){ saveConversationCacheForMe(); if(currentPartner && currentPartner.tf17===reader) renderConversation(me.tf17, reader); renderContacts(); }
          }
        } catch(e){}
      }
    } catch(err){ console.warn('WS parse err', err); }
  };
  ws.onclose = ()=> scheduleReconnect();
  ws.onerror = (e)=> { console.warn('WS error', e); if(ws) try{ ws.close(); }catch(e){}; };
}
function scheduleReconnect(){ if(reconnectTimer) return; reconnectTimer = setTimeout(()=>{ reconnectTimer=null; connectWS(); }, 3000); }

/* ================== read receipts ================== */
async function markAsReadAndNotifySender(other17, ref_time){
  if(!me.tf17 || !other17) return;
  const k = `${me.tf17}|${other17}`;
  const arr = conversationCache[k] || [];
  let changed=false; const cutoff = ref_time ? Date.parse(ref_time) : Date.now();
  arr.forEach(m=>{ const t = m.created_at ? Date.parse(m.created_at) : 0; if(t<=cutoff && m.from && m.from !== me.tf17){ if(!m._read){ m._read=true; changed=true; } }});
  if(changed) saveConversationCacheForMe();
  // notify sender via API (send small 'read' object)
  try {
    const payload = { type:'read', from: me.tf17, time: nowISO(), ref_time: (ref_time || nowISO()), name: me.name || null };
    await fetch(`${API_BASE}/api/add`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ tfid: other17, name: FRONTEND_NAME, content: JSON.stringify(payload) }) });
  } catch(e){ console.warn('send read failed', e); }
}

/* ================== OPEN / SEND chat ================== */
async function openChat(other17, contactObj=null, pushHistory=true){
  currentPartner = { tf17: other17, name: (contactObj && contactObj.name) || null };
  chatTitleEl.textContent = (currentPartner.name || formatTFShort(currentPartner.tf17));
  const c = contacts.find(x=>x.tf17===other17); if(c){ c.unread = 0; c.lastTs = Date.now(); saveState(); renderContacts(); }
  messagesEl.innerHTML = '<div class="muted">Chaje mesaj...</div>';
  await loadConversation(me.tf17 || null, other17);
  document.body.classList.add('chat-open'); chatModalEl.style.display='block'; setTimeout(()=> chatTextEl.focus(), 150);
  markAsReadAndNotifySender(other17, nowISO()).catch(()=>{});
}

async function sendMessageFromModal(){
  let txt = (chatTextEl.value||'').trim(); if(!txt) return;
  if(!me.tf17){ alert('Ou dwe mete TFID nan Param√®tres avan ou voye mesaj.'); return; }
  if(!currentPartner){ alert('Pa gen konv√®sasyon chwazi.'); return; }
  const recipient17 = currentPartner.tf17;
  const cid = makeCid();
  const payload = { type:'text', from: me.tf17, text: txt, time: nowISO(), cid, name: me.name || null };
  addOrUpdateMessageToCache(me.tf17, recipient17, { id:null, cid, from: me.tf17, text: txt, created_at: payload.time, parsed_time: payload.time, _optimistic:true });
  renderConversation(me.tf17, recipient17);
  chatTextEl.value = '';
  const c = contacts.find(x=>x.tf17===recipient17); if(c){ c.lastMsg = txt; c.lastTs = Date.now(); saveState(); renderContacts(); }
  try {
    await fetch(`${API_BASE}/api/add`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ tfid: recipient17, name: FRONTEND_NAME, content: JSON.stringify(payload) }) });
    // immediate: start a short poll for confirmation (optimistic)
    startShortPollForMessage(recipient17, cid);
  } catch(e){ alert('Envoi echwe: ' + (e.message||e)); }
}

function startShortPollForMessage(target17, cid){
  let tries=0; const maxTries=8; const interval=1200;
  const attempt = async ()=>{
    tries++;
    try {
      const r = await fetch(`${API_BASE}/api/list?tfid=${encodeURIComponent(target17)}&name=${encodeURIComponent(FRONTEND_NAME)}`);
      if(r.ok){
        const j = await r.json().catch(()=>null);
        if(j && Array.isArray(j.rows)){
          const found = j.rows.find(rr=>{ try { const p=JSON.parse(rr.content); return p && p.cid===cid; } catch(e){ return false; } });
          if(found){ await loadConversation(me.tf17, target17); return true; }
        }
      }
    } catch(e){}
    if(tries < maxTries) setTimeout(attempt, interval);
  };
  attempt();
}

/* ================== Storage helpers ================== */
function saveState(){ localStorage.setItem('tfchat.contacts', JSON.stringify(contacts||[])); localStorage.setItem('tfchat.groups', JSON.stringify(groups||[])); localStorage.setItem('tfchat.me.short', me.short || ''); localStorage.setItem('tfchat.me.17', me.tf17 || ''); localStorage.setItem('tfchat.me.name', me.name || ''); if(me.avatarDataUrl) localStorage.setItem('tfchat.me.avatar', me.avatarDataUrl); saveConversationCacheForMe(); }
function loadState(){ contacts = JSON.parse(localStorage.getItem('tfchat.contacts')||'[]')||[]; groups = JSON.parse(localStorage.getItem('tfchat.groups')||'[]')||[]; }

/* ================== UI wiring ================== */
document.getElementById('searchBtn').addEventListener('click', ()=> renderContacts(document.getElementById('searchInput').value));
document.getElementById('chatBack').addEventListener('click', ()=> { chatModalEl.style.display='none'; document.body.classList.remove('chat-open'); currentPartner=null; });
sendBtnEl.addEventListener('click', sendMessageFromModal);
chatTextEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendMessageFromModal(); } });

document.getElementById('appTitle').addEventListener('click', ()=> {
  // prompt minimal identity if not set (simple flow)
  if(!me.tf17){
    const short = prompt('Antre TFID 7 chif (ex: 0204143)') || '';
    const digits = normalizeInputToDigits(short);
    if(!digits || digits.length < 7){ alert('TFID pa valab'); return; }
    me.short = digits.slice(-7);
    me.tf17 = to17(me.short);
    me.name = prompt('Antre non ou pou show') || 'Utilisateur';
    saveState();
    loadConversationCacheForMe();
    connectWS();
    ensureSW().then(()=> subscribePushIfAllowed().catch(()=>{}));
    renderContacts();
    return;
  } else {
    alert('Pou chanje TFID, ou ka f√® sa nan Settings (pa implement√© avan).');
  }
});

/* ================== visibility / reconnect logic ================== */
document.addEventListener('visibilitychange', ()=>{
  if(!document.hidden){
    // resync unread convs and re-render
    contacts.filter(c=>c.unread).forEach(c=> loadConversation(me.tf17, c.tf17));
  }
});

/* ========== BOOT ========== */
loadState();
renderContacts();
if(me.tf17){
  loadConversationCacheForMe();
  connectWS();
  ensureSW().then(()=> { if(Notification.permission === 'granted' && !localStorage.getItem('tfchat.push.subscribed')) subscribePushIfAllowed().catch(()=>{}); });
} else {
  // no identity yet ‚Äî show lightweight hint
  console.log('No identity (me.tf17) set ‚Äî click title to set TFID quickly.');
}
</script>
</body>
  </html>
