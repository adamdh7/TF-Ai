<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TF-Chat — Push-like (700ms)</title>
<style>
  :root{--bg:#f2f2f5;--card:#fff;--muted:#6b6b6b;--accent:#128C7E;--unread:#ff4d4f;--radius:14px;--maxw:980px}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#111}
  .wrap{max-width:var(--maxw);margin:0 auto;height:100vh;display:flex;flex-direction:column}
  header{height:88px;display:flex;align-items:flex-end;padding:14px 16px;background:#fff;border-bottom:1px solid rgba(0,0,0,.06)}
  .title{font-weight:800;font-size:22px}
  .me-line{font-size:13px;color:var(--muted);margin-top:4px}
  main{flex:1;overflow:auto;padding:12px}
  .card{background:var(--card);padding:12px;border-radius:16px;margin-bottom:12px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .search{width:100%;padding:12px;border-radius:14px;border:1px solid #eee;font-size:16px;background:#fafafa}
  .row{display:flex;gap:8px;margin-top:10px}
  button{padding:10px 12px;border-radius:12px;border:0;background:var(--accent);color:#fff;cursor:pointer;font-weight:700}
  .btn-ghost{background:transparent;color:var(--accent);border:1px solid rgba(18,140,126,.12)}
  .contacts{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .contact{display:flex;align-items:center;gap:12px;padding:12px;background:#fff;border-radius:12px;cursor:pointer;border:1px solid #f0f0f0;position:relative}
  .avatar{width:48px;height:48px;border-radius:50%;background:#ddd;flex-shrink:0;overflow:hidden}
  .avatar img{width:100%;height:100%;object-fit:cover}
  .chat-page{display:flex;flex-direction:column;height:calc(100vh - 200px)}
  .chat-head{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid #eee}
  .chat-body{flex:1;overflow:auto;padding:12px;background:linear-gradient(#f2f2f5,#f8f8f8)}
  .messages{display:flex;flex-direction:column;gap:10px}
  .bubble{max-width:78%;padding:10px 14px;border-radius:16px;background:#fff;align-self:flex-start;word-break:break-word}
  .bubble.me{background:#dcf8c6;align-self:flex-end}
  .time{display:block;font-size:11px;color:var(--muted);margin-top:6px;text-align:right}
  .composer{display:flex;gap:8px;padding:10px;border-top:1px solid #eee;background:var(--card)}
  input[type="text"]{width:100%;padding:10px;border-radius:12px;border:1px solid #eee}
  .small{font-size:13px;color:var(--muted)}
  .unread-badge{position:absolute;right:12px;top:12px;background:var(--unread);color:#fff;border-radius:12px;padding:2px 8px;font-size:12px;font-weight:700}
  @media(min-width:900px){ .wrap{border-left:1px solid rgba(0,0,0,.04);border-right:1px solid rgba(0,0,0,.04)} }
</style>
</head>
<body>
<div class="wrap" id="app">
  <header>
    <div>
      <div class="title">TF-Chat</div>
      <div id="meLabel" class="me-line">Chargement...</div>
    </div>
  </header>

  <main id="main">
    <div class="card">
      <input id="searchInput" class="search" placeholder="Entrer TFID (ex: TF-0204143 ou 0204143) puis Appuyer Rechercher" />
      <div class="row" style="margin-top:10px">
        <button id="btnSearch">Rechercher</button>
        <button id="btnProfile" class="btn-ghost">Mon profil / Paramètres</button>
        <button id="btnTest" class="btn-ghost" style="margin-left:8px">Test envoi</button>
      </div>
      <div id="status" class="small" style="margin-top:8px;color:var(--muted)"></div>
    </div>

    <div class="card">
      <div class="small">Contacts récents</div>
      <div id="contacts" class="contacts"></div>
    </div>

    <div id="chatContainer"></div>
  </main>
</div>

<script>
/* ================= CONFIG ================= */
const CONFIG = {
  SAVE_HOST: "https://tf-sove.onrender.com",
  API_LIST: "/api/list",
  API_ADD: "/api/add",
  API_TOKEN: "tfstream_45dd9c02d4e34f18a42d",
  FRONTEND_NAME: "site1",
  UI_DIGITS: 7,
  SERVER_DIGITS: 17,
  POLL_MS: 700,                  // aggressive for near-instant push
  SESSION_KEY: "tfchat_session_site1_v3"
};

/* ================= STATE ================= */
let state = {
  me: null,
  contacts: [],     // {ui, server, name, avatarDataUrl, unread}
  messages: {},     // server -> [{id, from, text, time}]
  pollId: null,
  currentChatServer: null,
  lastSeenIds: {}   // server -> max id seen (for quick de-dupe)
};

/* ================ HELPERS ================ */
function el(tag, cls){ const e=document.createElement(tag); if(cls) e.className=cls; return e; }
function now(){ return new Date().toISOString(); }
function extractDigits(s){ const m=String(s||'').match(/\d+/g); return m? m.join('') : ''; }
function uiNormalize(v){ v = String(v||'').trim(); if(!v) return ''; if(v.startsWith('TF-')) return v; const d = extractDigits(v); return 'TF-' + d.padStart(CONFIG.UI_DIGITS,'0'); }
function uiRandom(){ return 'TF-' + Math.floor(1000000 + Math.random()*8999999).toString().padStart(CONFIG.UI_DIGITS,'0'); }
function uiToServer(ui){ const d=extractDigits(ui); if(!d) throw new Error('TFID invalide'); return d.padStart(CONFIG.SERVER_DIGITS,'0'); }
function saveSession(){ if(state.me) localStorage.setItem(CONFIG.SESSION_KEY, JSON.stringify(state.me)); else localStorage.removeItem(CONFIG.SESSION_KEY); }
function loadSession(){ try{ const s=localStorage.getItem(CONFIG.SESSION_KEY); return s? JSON.parse(s):null; }catch(e){ return null } }
function logSilent(...args){ console.debug('[TFCHAT]', ...args); } // silent UI logs (console only)

/* ================ NETWORK ================ */
async function apiList(serverTfid){
  const url = new URL(CONFIG.SAVE_HOST + CONFIG.API_LIST);
  url.searchParams.set('tfid', serverTfid);
  url.searchParams.set('name', CONFIG.FRONTEND_NAME);
  logSilent('API LIST GET', url.toString());
  const resp = await fetch(url.toString(), { method: 'GET', headers: { 'x-api-token': CONFIG.API_TOKEN }});
  const txt = await resp.text().catch(()=>'(no body)');
  let parsed = null;
  try{ parsed = JSON.parse(txt); }catch(e){ parsed = null; }
  if(!resp.ok) throw new Error(`LIST HTTP ${resp.status} — ${txt}`);
  logSilent('API LIST response', parsed || txt);
  return parsed || txt;
}

async function apiAdd(serverTfid, contentObj){
  const body = { tfid: serverTfid, name: CONFIG.FRONTEND_NAME, content: JSON.stringify(contentObj) };
  logSilent('API ADD POST', CONFIG.SAVE_HOST + CONFIG.API_ADD, body);
  const resp = await fetch(CONFIG.SAVE_HOST + CONFIG.API_ADD, {
    method: 'POST',
    headers: { 'Content-Type':'application/json', 'x-api-token': CONFIG.API_TOKEN },
    body: JSON.stringify(body)
  });
  const text = await resp.text().catch(()=>'(no body)');
  let parsed = null;
  try{ parsed = JSON.parse(text); }catch(e){ parsed = null; }
  logSilent('API ADD status', resp.status, parsed || text);
  if(!resp.ok){
    const err = (parsed && parsed.error) ? parsed.error : text;
    throw new Error(err || `HTTP ${resp.status}`);
  }
  return parsed || text;
}

/* ================ UI REFS ================ */
const meLabel = document.getElementById('meLabel');
const searchInput = document.getElementById('searchInput');
const btnSearch = document.getElementById('btnSearch');
const btnProfile = document.getElementById('btnProfile');
const btnTest = document.getElementById('btnTest');
const contactsDiv = document.getElementById('contacts');
const chatContainer = document.getElementById('chatContainer');
const statusEl = document.getElementById('status');

/* ================ UI LOGIC ================ */
btnSearch.onclick = async () => {
  const v = (searchInput.value || '').trim();
  if(!v){ alert('Veuillez entrer un TFID'); return; }
  let ui; try{ ui = uiNormalize(v); }catch(e){ alert('TFID invalide'); return; }
  let server; try{ server = uiToServer(ui); } catch(e){ alert('TFID invalide'); return; }
  status('Recherche...');
  try{
    const res = await apiList(server); // will succeed even if no messages; main point is server reachable
    addContactIfMissing(ui, server, ui);
    openChat(server, ui);
  }catch(e){
    alert('Recherche échouée: ' + (e.message||e));
  }finally{ status(''); }
};

btnProfile.onclick = () => {
  const newName = prompt('Votre nom / pseudo', state.me.name || state.me.ui) || state.me.name || state.me.ui;
  state.me.name = newName;
  saveSession();
  updateHeader();
  alert('Nom enregistré localement');
};

btnTest.onclick = async () => {
  if(!state.me) return alert('Session introuvable');
  const sample = { type:'text', from: state.me.server, text: 'PING ' + new Date().toISOString(), time: now() };
  try{ status('Test envoi...'); await apiAdd(state.me.server, sample); status(''); alert('Test envoi OK'); }catch(e){ status(''); alert('Test échoué: ' + (e.message||e)); }
};

function status(t){ statusEl.textContent = t || ''; }

/* ================ CONTACTS ================ */
function findContactByServer(server){ return state.contacts.find(c => c.server === server); }
function addContactIfMissing(ui, server, name, avatarDataUrl = null){
  let c = findContactByServer(server);
  if(!c){
    c = { ui, server, name: name || ui, avatarDataUrl: avatarDataUrl || null, unread: 0 };
    state.contacts.unshift(c);
    renderContacts();
  }
  return c;
}
function incrementUnread(server, count = 1){
  const c = findContactByServer(server);
  if(!c){ const ui = 'TF-' + server.slice(-7); addContactIfMissing(ui, server, ui); return incrementUnread(server,count); }
  if(state.currentChatServer === server) c.unread = 0; else c.unread = (c.unread||0)+count;
  renderContacts();
}
function clearUnread(server){ const c = findContactByServer(server); if(c){ c.unread = 0; renderContacts(); } }
function renderContacts(){
  contactsDiv.innerHTML = '';
  state.contacts.forEach(c=>{
    const row = el('div','contact');
    row.innerHTML = `<div class="avatar">${c.avatarDataUrl? '<img src="'+c.avatarDataUrl+'">' : ''}</div>
                     <div><strong>${c.name || c.ui}</strong><div class="small">${c.ui}</div></div>`;
    if(c.unread && c.unread > 0){
      const badge = el('div','unread-badge'); badge.textContent = c.unread>99 ? '99+' : String(c.unread); row.appendChild(badge);
    }
    row.onclick = ()=> openChat(c.server, c.ui);
    contactsDiv.appendChild(row);
  });
}

/* ================ CHAT ================ */
async function openChat(serverTfid, ui){
  state.currentChatServer = serverTfid;
  clearUnread(serverTfid);
  chatContainer.innerHTML = '';
  const wrapper = el('div','card');
  const head = el('div','chat-head');
  const contact = findContactByServer(serverTfid) || { ui, name: ui };
  head.innerHTML = `<div style="display:flex;gap:12px;align-items:center"><div class="avatar">${contact.avatarDataUrl? '<img src="'+contact.avatarDataUrl+'">' : ''}</div>
                    <div><strong>${contact.name || contact.ui}</strong><div class="small">${contact.ui}</div></div></div>`;
  wrapper.appendChild(head);

  const chatPage = el('div','chat-page');
  const chatBody = el('div','chat-body'); const msgs = el('div','messages'); chatBody.appendChild(msgs); chatPage.appendChild(chatBody);

  const composer = el('div','composer');
  const input = el('input'); input.type='text'; input.placeholder='Écrire un message...';
  const sendBtn = el('button'); sendBtn.textContent = 'Envoyer';
  composer.appendChild(input); composer.appendChild(sendBtn);
  chatPage.appendChild(composer);
  wrapper.appendChild(chatPage);
  chatContainer.appendChild(wrapper);

  // load messages
  state.messages[serverTfid] = state.messages[serverTfid] || [];
  try{
    const j = await apiList(serverTfid);
    if(j && j.ok && Array.isArray(j.rows)){
      const rows = j.rows.slice().reverse();
      rows.forEach(r=>{
        if(state.messages[serverTfid].some(m=>m.id === r.id)) return;
        try{
          const payload = JSON.parse(r.content);
          const obj = { id: r.id, from: payload.from||'unknown', text: payload.text||payload.message||'', time: r.created_at };
          state.messages[serverTfid].push(obj);
          state.lastSeenIds[serverTfid] = Math.max(state.lastSeenIds[serverTfid]||0, r.id||0);
        }catch(e){
          const obj = { id: r.id, from: 'unknown', text: r.content||'', time: r.created_at };
          state.messages[serverTfid].push(obj);
        }
      });
    }
  }catch(e){ logSilent('openChat apiList error', e.message||e); }

  function renderMessages(){
    msgs.innerHTML = '';
    const arr = state.messages[serverTfid] || [];
    arr.forEach(m=>{
      const meClass = (state.me && m.from === state.me.server);
      const b = el('div','bubble ' + (meClass? 'me' : ''));
      const html = String(m.text||'').replace(/TF-(\d+)/g, match => `<span class="link-tfid">${match}</span>`);
      b.innerHTML = html + `<div class="time">${m.time? new Date(m.time).toLocaleTimeString(): ''}</div>`;
      setTimeout(()=> b.querySelectorAll('.link-tfid').forEach(elm => elm.onclick = () => {
        const u = elm.textContent;
        try{ const srv = uiToServer(u); if(!findContactByServer(srv)) addContactIfMissing(u,srv,u); openChat(srv,u); }catch(err){ alert('TFID invalide'); }
      }),0);
      msgs.appendChild(b);
    });
    msgs.scrollTop = msgs.scrollHeight;
  }

  window.renderChatRefresh = function(tfid){ if(tfid===serverTfid) renderMessages(); };

  // SEND: send -> copy to self -> immediate refresh -> increment unread on recipient if not open
  sendBtn.onclick = async () => {
    const txt = input.value.trim(); if(!txt) return;
    if(!state.me) return alert('Veuillez configurer votre pseudo');
    const local = { id:null, from: state.me.server, text: txt, time: now() };
    state.messages[serverTfid] = state.messages[serverTfid] || []; state.messages[serverTfid].push(local);
    renderMessages(); input.value = '';
    const payload = { type:'text', from: state.me.server, text: txt, time: now() };

    try{
      status('Envoi...');
      // 1) send to recipient
      const resp = await apiAdd(serverTfid, payload);
      logSilent('apiAdd recipient', resp);
      // 2) copy to self timeline (history)
      await apiAdd(state.me.server, payload).catch(e => logSilent('copy-to-self failed', e));
      // 3) immediate refresh: fetch recipient & self timeline
      const [destRes, selfRes] = await Promise.allSettled([ apiList(serverTfid).catch(()=>null), apiList(state.me.server).catch(()=>null) ]);
      if(destRes.status==='fulfilled' && destRes.value && destRes.value.ok){
        const rows = destRes.value.rows.slice().reverse();
        rows.forEach(rw=>{
          if(state.messages[serverTfid].some(m=>m.id===rw.id)) return;
          try{
            const p = JSON.parse(rw.content);
            const obj = { id: rw.id, from: p.from||'unknown', text: p.text||p.message||'', time: rw.created_at };
            state.messages[serverTfid].push(obj);
            state.lastSeenIds[serverTfid] = Math.max(state.lastSeenIds[serverTfid]||0, rw.id||0);
          }catch(e){
            const obj = { id: rw.id, from:'unknown', text: rw.content||'', time: rw.created_at };
            state.messages[serverTfid].push(obj);
          }
        });
      }
      if(selfRes.status==='fulfilled' && selfRes.value && selfRes.value.ok){
        const rows = selfRes.value.rows.slice().reverse();
        const meSrv = state.me.server;
        state.messages[meSrv] = state.messages[meSrv] || [];
        rows.forEach(rw=>{
          if(state.messages[meSrv].some(m=>m.id===rw.id)) return;
          try{
            const p = JSON.parse(rw.content);
            const obj = { id: rw.id, from: p.from||'unknown', text: p.text||p.message||'', time: rw.created_at };
            state.messages[meSrv].push(obj);
            state.lastSeenIds[meSrv] = Math.max(state.lastSeenIds[meSrv]||0, rw.id||0);
          }catch(e){ const obj = { id: rw.id, from:'unknown', text: rw.content||'', time: rw.created_at }; state.messages[meSrv].push(obj); }
        });
      }
      // 4) unread handling for recipient
      if(state.currentChatServer !== serverTfid) incrementUnread(serverTfid, 1); else clearUnread(serverTfid);
      // 5) try notify recipient (browser notification if they have the page open & we detected them via polling)
      // (polling will pick it up quickly; we'll also trigger a micro-refresh in pollOwn)
      status('');
      logSilent('sent and refreshed');
    }catch(err){
      status(''); logSilent('send failed', err && err.message ? err.message : err); alert('Envoi échoué: ' + (err.message||err));
    }
    renderMessages();
  };

  input.addEventListener('keydown', e => { if(e.key==='Enter'){ e.preventDefault(); sendBtn.click(); } });
  renderMessages();
}

/* ================ POLLING (for near-instant push) ================ */
async function pollOwn(){
  if(!state.me) return;
  try{
    const j = await apiList(state.me.server);
    if(j && j.ok && Array.isArray(j.rows)){
      const rows = j.rows.slice().reverse();
      for(const r of rows){
        const tgt = r.tfid;
        state.messages[tgt] = state.messages[tgt] || [];
        if(state.messages[tgt].some(m=>m.id === r.id)) continue;
        try{
          const payload = JSON.parse(r.content);
          const mobj = { id: r.id, from: payload.from || 'unknown', text: payload.text || payload.message || '', time: r.created_at };
          state.messages[tgt].push(mobj);
          // If message is for me (tgt === my server) then origin = payload.from
          if(tgt === state.me.server){
            const fromSrv = payload.from || 'unknown';
            const ui = 'TF-' + fromSrv.slice(-7);
            addContactIfMissing(ui, fromSrv, ui);
            if(state.currentChatServer === fromSrv){
              if(window.renderChatRefresh) window.renderChatRefresh(fromSrv);
              clearUnread(fromSrv);
            } else {
              incrementUnread(fromSrv, 1);
              // show browser notification if permitted
              showBrowserNotification(`Nouveau message de ${ui}`, payload.text || '');
            }
          } else {
            // message stored for another tfid (rare)
            if(state.currentChatServer === tgt && window.renderChatRefresh) window.renderChatRefresh(tgt);
          }
        }catch(e){
          const mobj = { id: r.id, from: 'unknown', text: r.content || '', time: r.created_at };
          state.messages[tgt].push(mobj);
        }
      }
    }
  }catch(e){ logSilent('pollOwn error', e && e.message ? e.message : e); }
}

/* ================ NOTIFICATIONS ================ */
function showBrowserNotification(title, body){
  if(document.hidden) { // only notify when tab not visible
    if(Notification && Notification.permission === 'granted'){
      try{ new Notification(title, { body, icon: '' }); }catch(e){ logSilent('notif fail', e); }
    } else if(Notification && Notification.permission !== 'denied'){
      Notification.requestPermission().then(p => { if(p==='granted') new Notification(title, { body }); });
    }
  }
}

/* ================ HEADER ================ */
function updateHeader(){ if(state.me) meLabel.textContent = `${state.me.name || state.me.ui} • ${state.me.ui}`; else meLabel.textContent = 'Non configuré'; }

/* ================ INIT ================ */
(function init(){
  try{
    const s = loadSession();
    if(s && s.ui && s.server){ state.me = s; } else {
      const ui = uiRandom();
      state.me = { ui, server: uiToServer(ui), name: 'Moi', avatarDataUrl: null };
      saveSession();
    }
  }catch(e){
    const ui = uiRandom();
    state.me = { ui, server: ui.replace(/TF-/, '').padStart(17,'0'), name:'Moi', avatarDataUrl:null };
    saveSession();
  }
  updateHeader();

  // default contact Adam_D'H7
  addContactIfMissing('TF-7777777', uiToServer('TF-7777777'), "Adam_D'H7");
  renderContacts();

  // start polling
  pollOwn();
  state.pollId = setInterval(pollOwn, CONFIG.POLL_MS);

  // request notification permission early (quiet)
  if("Notification" in window && Notification.permission === "default"){
    Notification.requestPermission().then(()=>{/* silent */});
  }

  logSilent('Init complete', { me: state.me, frontendName: CONFIG.FRONTEND_NAME });
})();

/* ================ UTILITIES ================ */
function addContactIfMissing(ui, server, name, avatarDataUrl=null){
  let c = findContactByServer(server);
  if(!c){ c = { ui, server, name: name||ui, avatarDataUrl: avatarDataUrl||null, unread: 0 }; state.contacts.unshift(c); renderContacts(); }
  return c;
}
function findContactByServer(server){ return state.contacts.find(c => c.server === server); }
function uiToServer(ui){ const d = extractDigits(ui); if(!d) throw new Error('TFID invalide'); return d.padStart(CONFIG.SERVER_DIGITS,'0'); }

/* Expose minimal debug in console only */
window.TFCHAT = { state, apiList, apiAdd, pollOwn };

</script>
</body>
</html>
