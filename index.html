<!DOCTYPE html>
<html lang="ht">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>TF-Chat</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" type="image/jpeg" href="https://files.catbox.moe/ixgmht.jpg" />
<link rel="apple-touch-icon" href="https://files.catbox.moe/ixgmht.jpg" />
<meta name="theme-color" content="#000000">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;600;700&display=swap" rel="stylesheet">
<style>
/* (Same CSS as you had; adjusted a tiny bit for svg send and checks) */
:root{ --bg:#000000; --panel:#000000; --text:#e6eefb; --muted:#9aa6bf; --card:#0b0b0b; --accent:#0b81ff; --header-h:56px; --tab-h:62px; --msg-line-height:1.35rem; --msg-max-lines:8; }
*{box-sizing:border-box}
html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Roboto,system-ui,Arial,sans-serif;-webkit-font-smoothing:antialiased}
header{position:fixed;left:0;right:0;top:0;height:var(--header-h);display:flex;align-items:center;justify-content:center;background:var(--panel);z-index:1000;border-bottom:1px solid rgba(255,255,255,0.03)}
.app-title{font-weight:700;font-size:18px;cursor:pointer}
main{position:fixed;left:0;right:0;top:var(--header-h);bottom:var(--tab-h);overflow:auto;padding:12px;margin:0 auto;max-width:980px}
body.chat-open main > section { display:none !important; }
.tabbar { position:fixed; left:0; right:0; bottom:0; height:var(--tab-h); display:flex; gap:0; border-top:1px solid rgba(255,255,255,0.03); background:var(--panel); align-items:center; justify-content:center; z-index:1000; }
.tab { flex:1; text-align:center; padding:10px 6px; cursor:pointer; font-weight:700; color:var(--muted); }
.tab.active{ color:var(--text); border-top:3px solid var(--accent); background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }
.search{padding:8px 12px;display:flex;justify-content:center}
.search-box{display:flex;align-items:center;gap:8px;background:var(--card);padding:10px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);width:100%;max-width:980px}
.search-box input{flex:1;background:transparent;border:0;outline:none;color:var(--text);font-size:15px}
.search-btn{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
.list{margin-top:12px}
.contact{display:flex;gap:12px;align-items:center;padding:12px;border-radius:12px;cursor:pointer;width:100%}
.contact:hover{background:rgba(255,255,255,0.02)}
.avatar{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));display:inline-flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;color:var(--text);flex-shrink:0;overflow:hidden}
.avatar img{width:100%;height:100%;object-fit:cover;border-radius:50%}
.meta{flex:1;min-width:0}
.meta-top{display:flex;justify-content:space-between;align-items:flex-start}
.name{font-weight:600;font-size:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.time{font-size:12px;color:var(--muted)}
.meta-bottom{display:flex;justify-content:space-between;margin-top:6px;align-items:center}
.snippet{font-size:13px;color:var(--muted);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.badge{background:var(--accent);color:white;padding:4px 8px;border-radius:999px;font-weight:600;font-size:13px}
.messages-wrap{padding:12px;height:calc(100% - 56px - 84px);overflow:auto;display:flex;flex-direction:column;gap:8px}
.messages{display:flex;flex-direction:column;gap:8px}
.msg{max-width:74%;padding:10px;border-radius:12px;margin-bottom:4px;word-break:break-word;overflow:hidden;display:inline-block}
.msg.bot{background:#121212;color:var(--text);align-self:flex-start}
.msg.user{background:linear-gradient(180deg,var(--accent),#0563c9);color:white;align-self:flex-end}
.msg .checks{font-size:11px;margin-left:8px;opacity:0.9}
.msg .checks.read{opacity:1;font-weight:700}
.msg-text{ white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; display:block; line-height: var(--msg-line-height); max-height: calc(var(--msg-line-height) * var(--msg-max-lines)); }
.msg-meta{font-size:11px;color:var(--muted);margin-top:6px;display:flex;gap:8px;align-items:center}
.chat-input{display:flex;gap:8px;align-items:center;padding:12px;border-top:1px solid rgba(255,255,255,0.03);background:transparent}
.input{flex:1;padding:12px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);background:var(--card);color:var(--text);outline:none;min-width:0}
.send-btn{background:transparent;border:0;padding:8px;border-radius:10px;cursor:pointer;color:var(--accent);display:inline-flex;align-items:center;justify-content:center}
.muted{text-align:center;color:var(--muted);padding:20px}
@media (min-width:900px){main{max-width:700px;margin:0 auto}}
</style>
</head>
<body>
  <header><div class="app-title">TF-Chat</div></header>

  <main>
    <section id="section-accueil">
      <section class="search">
        <div class="search-box" role="search">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" aria-hidden="true"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6"/><circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.6"/></svg>
          <input id="searchInput" placeholder="Recherche (TFID ou 7 chif)" aria-label="Recherche" />
          <button id="searchBtn" class="search-btn">Rechercher</button>
        </div>
      </section>

      <section class="list" id="contactsList" aria-live="polite"></section>
    </section>
    <section id="section-groupes" style="display:none">
      <!-- groups UI (kept same) -->
    </section>
  </main>

  <div class="tabbar">
    <div id="tabAccueil" class="tab active">Accueil</div>
    <div id="tabGroupes" class="tab">Groupes</div>
  </div>

  <!-- Chat modal -->
  <div id="chatModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.96);z-index:1200">
    <div style="height:100%;display:flex;flex-direction:column">
      <div style="height:56px;display:flex;align-items:center;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.03)">
        <button id="chatBack" style="background:transparent;border:0;color:var(--text);cursor:pointer">←</button>
        <div style="flex:1;text-align:center;font-weight:700;cursor:pointer" id="chatTitle">Chat</div>
        <div style="width:44px"></div>
      </div>
      <div class="messages-wrap">
        <div class="messages" id="messages" aria-live="polite" role="log"></div>
      </div>
      <div class="chat-input" id="chatInputRow">
        <input id="chatText" class="input" placeholder="Ekri mesaj..." autocomplete="off" />
        <!-- REAL SVG send (not emoji) -->
        <button id="sendBtn" class="send-btn" aria-label="Envoyer" title="Envoyer">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M2 21L23 12 2 3v7l15 2-15 2v7z" fill="currentColor"/></svg>
        </button>
      </div>
    </div>
  </div>

<script>
/* ================== CONFIG ================== */
const API_BASE = 'https://tf-sove.onrender.com';
const PROFILE_UPLOAD_URL = API_BASE + '/upload';
const FRONTEND_NAME = 'site1';
const ADMIN_API_TOKEN = 'tfstream_45dd9c02d4e34f18a42d';
const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + "tf-sove.onrender.com/ws";

/* Notification icon (replace path by your asset) */
const NOTIF_ICON = '/images/tf-notif.png';

/* Helpers */
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function makeCid(){ return String(Date.now()) + '-' + Math.floor(Math.random()*100000).toString(16); }
function nowISO(){ return (new Date()).toISOString(); }
function timeAgo(ts){ if(!ts) return ''; const diff=Math.floor((Date.now()-ts)/1000); if(diff<60) return diff+'s'; if(diff<3600) return Math.floor(diff/60)+'m'; if(diff<86400) return Math.floor(diff/3600)+'h'; return new Date(ts).toLocaleDateString(); }
function formatTFShort(digitsString){ if(!digitsString) return ''; const s=String(digitsString).replace(/[^0-9]/g,''); const last7 = s.slice(-7); return 'TF-'+ last7.padStart(7,'0'); }

/* ================== STATE ================== */
let me = {
  short: localStorage.getItem('tfchat.me.short') || null,
  tf17: localStorage.getItem('tfchat.me.17') || null,
  name: localStorage.getItem('tfchat.me.name') || 'Utilisateur',
  avatarDataUrl: localStorage.getItem('tfchat.me.avatar') || null
};
if(me.tf17) me.tf17 = me.tf17.replace(/\s+/g,'');
let contacts = JSON.parse(localStorage.getItem('tfchat.contacts') || '[]') || [];
contacts = contacts.map(c => { if(c && c.tf17) c.tf17 = (c.tf17||'').replace(/\s+/g,''); return c; });
let groups = JSON.parse(localStorage.getItem('tfchat.groups') || '[]') || [];
let conversationCache = {}; // in-memory; persisted per-user
try { conversationCache = JSON.parse(localStorage.getItem('tfchat.conv.' + (me.tf17||'anon')) || '{}') || {}; } catch(e){ conversationCache = {}; }

/* ========== SERVICE WORKER + PUSH ========== */
async function fetchVapidPublicKey(){
  try {
    const r = await fetch(API_BASE + '/api/vapid');
    if(!r.ok) return '';
    const j = await r.json().catch(()=>null);
    return j && j.publicKey ? j.publicKey : '';
  } catch(e){ return ''; }
}
function urlBase64ToUint8Array(base64String) {
  if(!base64String) return null;
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
  return outputArray;
}

async function ensureSWRegistered(){
  if(!('serviceWorker' in navigator)) return null;
  try {
    const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
    console.log('SW registered:', reg.scope);
    return reg;
  } catch (e) {
    console.warn('SW register failed', e);
    return null;
  }
}

async function subscribePushIfAllowed(){
  if(!('serviceWorker' in navigator) || !('PushManager' in window)) return false;
  if (!me.tf17) return false; // must have TFID before subscribe
  let perm = Notification.permission;
  if(perm !== 'granted') perm = await Notification.requestPermission();
  if(perm !== 'granted') return false;
  const reg = await ensureSWRegistered();
  if(!reg) return false;
  const publicKey = await fetchVapidPublicKey();
  if(!publicKey) { console.warn('VAPID public key not available'); return false; }
  try {
    const sub = await reg.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(publicKey)
    });
    // send to server
    await fetch(API_BASE + '/api/subscribe', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ tfid: me.tf17, subscription: sub })
    });
    localStorage.setItem('tfchat.push.subscribed', '1');
    console.log('Push subscription saved.');
    return true;
  } catch(e){ console.warn('subscribePush failed', e); return false; }
}

/* Show notification immediately via SW (for messages received via WS when page hidden) */
async function showLocalNotification(title, body, data = {}) {
  try {
    if ('serviceWorker' in navigator) {
      const reg = await navigator.serviceWorker.ready;
      reg.showNotification(title, { body, icon: NOTIF_ICON, badge: NOTIF_ICON, data, renotify: true, vibrate: [100,50,100] });
      return;
    }
    if (Notification.permission === 'granted') new Notification(title, { body, icon: NOTIF_ICON, data });
  } catch(e){ console.warn('showLocalNotification err', e); }
}

/* ========== STORAGE helpers ========== */
function saveState(){
  localStorage.setItem('tfchat.contacts', JSON.stringify(contacts||[]));
  localStorage.setItem('tfchat.groups', JSON.stringify(groups||[]));
  localStorage.setItem('tfchat.me.short', me.short || '');
  localStorage.setItem('tfchat.me.17', me.tf17 || '');
  localStorage.setItem('tfchat.me.name', me.name || '');
  if(me.avatarDataUrl) localStorage.setItem('tfchat.me.avatar', me.avatarDataUrl);
  // persist conv for current me
  try { localStorage.setItem('tfchat.conv.' + (me.tf17||'anon'), JSON.stringify(conversationCache || {})); } catch(e){ console.warn('persist conv fail', e); }
}
function ensureConvKey(a,b){ if(!a||!b) return ''; return `${a}|${b}`; }
function addOrUpdateMessageToCache(me17, other17, m){
  const k = ensureConvKey(me17, other17);
  if(!conversationCache[k]) conversationCache[k] = [];
  const arr = conversationCache[k];
  const foundIdx = m.cid ? arr.findIndex(x=>x.cid===m.cid) : (m.id ? arr.findIndex(x=>String(x.id)===String(m.id)) : -1);
  if(foundIdx !== -1) { arr[foundIdx] = Object.assign({}, arr[foundIdx], m); }
  else arr.push(m);
  arr.sort((a,b) => (new Date(a.created_at || a._db_created_at || 0)) - (new Date(b.created_at || b._db_created_at || 0)));
  saveState();
}

/* mark read up to time */
async function markAsReadAndNotifySender(other17, ref_time){
  const k = ensureConvKey(me.tf17, other17);
  const arr = conversationCache[k] || [];
  let changed = false;
  const cutoff = ref_time ? Date.parse(ref_time) : Date.now();
  arr.forEach(m => {
    const t = m.created_at ? Date.parse(m.created_at) : 0;
    if (t <= cutoff && m.from && m.from !== me.tf17) {
      if (!m._read) { m._read = true; changed = true; }
    }
  });
  if(changed) saveState();
  // send read receipt to other17
  try {
    if(me.tf17) {
      const payload = { type: 'read', from: me.tf17, time: nowISO(), ref_time: (ref_time || nowISO()), name: me.name || null };
      await fetch(API_BASE + '/api/add', { method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ tfid: other17, name: FRONTEND_NAME, content: JSON.stringify(payload) }) });
    }
  } catch(e){ console.warn('send read failed', e); }
}

/* ========== RENDER / UI ========== */
const contactsListEl = document.getElementById('contactsList');
const messagesEl = document.getElementById('messages');
const chatModalEl = document.getElementById('chatModal');
const chatTitleEl = document.getElementById('chatTitle');
const chatTextEl = document.getElementById('chatText');
const sendBtnEl = document.getElementById('sendBtn');

function renderContacts(filter='') {
  contactsListEl.innerHTML = '';
  const q = (filter||'').toLowerCase().trim();
  const list = contacts.filter(c => { if(!q) return true; return (c.name||'').toLowerCase().includes(q) || (c.tf17||'').toLowerCase().includes(q); });
  if(list.length === 0){
    const div = document.createElement('div'); div.className='muted'; div.textContent='Pa gen kontak. Rechèch yon TFID oswa ajoute yon kontak.'; contactsListEl.appendChild(div); return;
  }
  list.forEach(c => {
    const el = document.createElement('div'); el.className='contact'; el.dataset.tf17 = c.tf17 || '';
    const avatarHtml = c.logo ? `<img src="${c.logo}" style="width:100%;height:100%;border-radius:50%">` : (c.avatar ? `<img src="${c.avatar}" />` : escapeHtml((c.name||formatTFShort(c.tf17) || '').slice(0,2)));
    el.innerHTML = `<div class="avatar">${avatarHtml}</div>
      <div class="meta">
        <div class="meta-top">
          <div class="name">${escapeHtml(c.name||formatTFShort(c.tf17)||'')}</div>
          <div class="time">${c.lastTs? timeAgo(c.lastTs): ''}</div>
        </div>
        <div class="meta-bottom">
          <div class="snippet">${escapeHtml(c.lastMsg||'')}</div>
          <div>${c.unread?'<span class="badge">'+c.unread+'</span>':''}</div>
        </div>
      </div>`;
    el.addEventListener('click', ()=> { openChat(c.tf17, c, true); });
    contactsListEl.appendChild(el);
  });
}
function renderConversation(me17, other17){
  const key = ensureConvKey(me17, other17);
  const arr = (conversationCache[key] || []).slice();
  arr.sort((a,b) => new Date(a.created_at || a._db_created_at || 0) - new Date(b.created_at || b._db_created_at || 0));
  messagesEl.innerHTML = '';
  if(arr.length === 0){ const d = document.createElement('div'); d.className='muted'; d.textContent='Pa gen mesaj ankò.'; messagesEl.appendChild(d); return; }
  arr.forEach(m => {
    const fromNorm = m.from || '';
    const isMe = (fromNorm === me17);
    const d = document.createElement('div'); d.className = 'msg ' + (isMe ? 'user' : 'bot');
    const textBlock = document.createElement('div'); textBlock.className = 'msg-text';
    textBlock.appendChild(document.createTextNode(m.text || m.content || ''));
    const meta = document.createElement('div'); meta.className = 'msg-meta';
    const ts = m.created_at ? (new Date(m.created_at)).toLocaleString() : '';
    const checksEl = document.createElement('span'); checksEl.style.marginLeft = '8px';
    checksEl.className = 'checks' + ((isMe && m._read) ? ' read' : '');
    if(isMe){
      checksEl.textContent = m._read ? '✓✓' : (m.id ? '✓✓' : '✓');
    }
    meta.textContent = `${formatTFShort(m.from||'')} • ${ts} `;
    meta.appendChild(checksEl);
    d.appendChild(textBlock); d.appendChild(meta);
    messagesEl.appendChild(d);
  });
  setTimeout(()=> { const wrap = document.querySelector('#chatModal .messages-wrap'); if(wrap) wrap.scrollTop = wrap.scrollHeight; }, 40);
}

/* ========== NETWORK helpers ========== */
async function callJSON(url, opts = {}) { opts = Object.assign({}, opts); opts.headers = Object.assign({}, opts.headers || {}, { 'Accept': 'application/json' }); try { const r = await fetch(url, opts); const text = await r.text(); let json = null; try{ json = JSON.parse(text); }catch(e){} return { ok: r.ok, status: r.status, json, text }; } catch (err) { return { ok: false, error: err.message }; } }

async function apiAdd(recipient17, contentObj){
  const body = { tfid: recipient17, name: FRONTEND_NAME, content: JSON.stringify(contentObj), source_url: location.origin };
  const url = `${API_BASE}/api/add`;
  const r = await callJSON(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
  if(!r.ok) throw new Error(r.json?.error || r.text || `HTTP ${r.status}`);
  return r.json;
}

/* ========== READ receipts ========== */
async function sendReadReceipt(toTf17, ref_time){
  if(!me.tf17 || !toTf17) return;
  const payload = { type:'read', from: me.tf17, time: nowISO(), ref_time: ref_time || nowISO(), name: me.name || null };
  try { await apiAdd(toTf17, payload); } catch(e){ console.warn('sendReadReceipt err', e); }
}

/* ========== OPEN / SEND flows ========== */
let currentPartner = null;
async function openChat(other17, contactObj=null, pushHistory=true){
  const otherN = other17;
  currentPartner = { tf17: otherN, name: (contactObj && contactObj.name) || null };
  chatTitleEl.textContent = (currentPartner.name || formatTFShort(currentPartner.tf17));
  const c = contacts.find(x => x.tf17 === otherN);
  if(c){ c.unread = 0; c.lastTs = Date.now(); saveState(); renderContacts(); }
  messagesEl.innerHTML = '<div class="muted">Chaje mesaj...</div>';
  try { await loadConversation(me.tf17 || null, otherN); } catch(e){ messagesEl.innerHTML = `<div class="muted">Pa kapab chaje mesaj: ${escapeHtml(e.message||e)}</div>`; }
  document.body.classList.add('chat-open'); chatModalEl.style.display = 'block'; setTimeout(()=> chatTextEl?.focus(), 120);
  // mark messages read and send read receipt
  markAsReadAndNotifySender(otherN, nowISO()).catch(()=>{});
}

async function sendMessageFromModal(){
  let txt = (chatTextEl?.value || '').trim();
  if(!txt) return;
  if(!me.tf17){ alert('Ou dwe mete TFID nan Paramètres avan ou voye mesaj.'); return; }
  if(!currentPartner){ alert('Pa gen konvèsasyon chwazi.'); return; }
  const recipient17 = currentPartner.tf17;
  const cid = makeCid();
  const payload = { type:'text', from: me.tf17, text: txt, time: nowISO(), cid, name: me.name || null };
  // optimistic add
  addOrUpdateMessageToCache(me.tf17, recipient17, { id:null, cid, from: me.tf17, text: txt, created_at: payload.time, parsed_time: payload.time, _optimistic:true });
  renderConversation(me.tf17, recipient17);
  chatTextEl.value = '';
  const c = contacts.find(x=> x.tf17 === recipient17);
  if(c){ c.lastMsg = txt; c.lastTs = Date.now(); saveState(); renderContacts(); }
  try {
    await apiAdd(recipient17, payload);
  } catch(e){
    alert('Envoi echwe: ' + (e.message||e));
  }
}

/* ========== SYNC (loadConversation) ========== */
async function loadConversation(me17, other17){
  if(!me17 || !other17) return;
  try {
    // fetch outgoing for other (messages sent to others)
    const out = await callJSON(`${API_BASE}/api/list?tfid=${encodeURIComponent(other17)}&name=${encodeURIComponent(FRONTEND_NAME)}`);
    if(out.ok && out.json && Array.isArray(out.json.rows)) {
      for(const r of out.json.rows){
        let parsed = null;
        try{ parsed = JSON.parse(r.content); }catch(e){ parsed = null; }
        const from = parsed && parsed.from ? parsed.from : null;
        if(!from) continue;
        const text = parsed && (parsed.text||parsed.message) ? (parsed.text||parsed.message) : r.content;
        addOrUpdateMessageToCache(me17, other17, { id: r.id, cid: parsed && parsed.cid ? parsed.cid : null, from, text, created_at: parsed?.time || r.created_at || nowISO(), _db_created_at: r.created_at });
      }
    }
    // fetch incoming for me
    const inc = await callJSON(`${API_BASE}/api/list?tfid=${encodeURIComponent(me17)}&name=${encodeURIComponent(FRONTEND_NAME)}`);
    if(inc.ok && inc.json && Array.isArray(inc.json.rows)) {
      for(const r of inc.json.rows){
        let parsed = null;
        try{ parsed = JSON.parse(r.content); }catch(e){ parsed = null; }
        const from = parsed && parsed.from ? parsed.from : null;
        if(!from) continue;
        const text = parsed && (parsed.text||parsed.message) ? (parsed.text||parsed.message) : r.content;
        addOrUpdateMessageToCache(me17, other17, { id: r.id, cid: parsed && parsed.cid ? parsed.cid : null, from, text, created_at: parsed?.time || r.created_at || nowISO(), _db_created_at: r.created_at });
      }
    }
    saveState();
    renderConversation(me17, other17);
  } catch(e){ console.warn('loadConversation error', e); }
}

/* ========== WebSocket client (with robust reconnect + resync) ========== */
let ws = null; let reconnectTimer = null;
function connectWS(){
  if(!me.tf17) return;
  try { ws = new WebSocket(WS_URL); } catch(e){ scheduleReconnect(); return; }
  ws.onopen = async ()=> {
    try{ ws.send(JSON.stringify({ type:'subscribe', tfid: me.tf17 })); }catch(e){}
    // on reconnect, resync unread conversations
    contacts.filter(c => c.unread && c.tf17).forEach(c => { loadConversation(me.tf17, c.tf17).catch(()=>{}); });
    // try to subscribe to push server (one-time)
    if(Notification.permission === 'granted' && !localStorage.getItem('tfchat.push.subscribed')) {
      await subscribePushIfAllowed().catch(()=>{});
    }
  };
  ws.onmessage = async (ev) => {
    try {
      const data = JSON.parse(ev.data);
      if(data.type === 'subscribed') return;
      if(data.type === 'message') {
        // message object from server: contains id, tfid (recipient), name, content, etc
        let parsed = null;
        try { parsed = JSON.parse(data.content || JSON.stringify(data)); } catch(e){ parsed = data.content || {}; }
        const from = parsed && parsed.from ? parsed.from : (data.from || null);
        if(!from) return;
        const other = (data.tfid === me.tf17) ? from : (data.tfid || from);
        const created_at = parsed && parsed.time ? parsed.time : (data.created_at || nowISO());
        const cid = parsed && parsed.cid ? parsed.cid : null;
        const text = parsed && (parsed.text||parsed.message) ? (parsed.text||parsed.message) : (data.content || '');
        const msgObj = { id: data.id || null, cid, from, text, created_at, _db_created_at: data.created_at || null };
        addOrUpdateMessageToCache(me.tf17, other, msgObj);
        // if current chat open with this user => render and send read receipt
        if(currentPartner && currentPartner.tf17 === other){
          renderConversation(me.tf17, other);
          // mark read + send read receipt
          markAsReadAndNotifySender(other, nowISO()).catch(()=>{});
        } else {
          // not in chat: increment unread, save and notify
          const c = contacts.find(x=> x.tf17 === other) || (function(){ const newc = { tf17: other, name: parsed && parsed.name ? parsed.name : formatTFShort(other), unread:0, lastMsg:'', lastTs: Date.now(), avatar:null }; contacts.unshift(newc); saveState(); return newc; })();
          c.unread = (c.unread||0) + 1;
          c.lastMsg = text;
          c.lastTs = Date.now();
          saveState();
          renderContacts();
          // show system notification when tab hidden or not focused
          if(document.hidden || !document.hasFocus()){
            const title = parsed && parsed.name ? parsed.name : formatTFShort(other);
            await showLocalNotification(title, text || 'Nouveau message', { tfid: other });
          }
        }
      }
      // handle read receipts from others: if parsed.type === 'read' and parsed.from => mark our messages to that person as read
      if(data.type === 'message') {
        try {
          const parsed2 = JSON.parse(data.content || '{}');
          if(parsed2 && parsed2.type === 'read' && parsed2.from && parsed2.ref_time){
            // they read messages we sent earlier; mark our messages to them as read
            const reader = parsed2.from;
            const k = ensureConvKey(me.tf17, reader);
            const arr = conversationCache[k] || [];
            let changed = false;
            const cutoff = parsed2.ref_time ? Date.parse(parsed2.ref_time) : Date.now();
            arr.forEach(m => { const t = m.created_at ? Date.parse(m.created_at) : 0; if(t <= cutoff && m.from === me.tf17 && !m._read){ m._read = true; changed = true; }});
            if(changed) { saveState(); if(currentPartner && currentPartner.tf17 === reader) renderConversation(me.tf17, reader); renderContacts(); }
          }
        } catch(e){}
      }
    } catch(err){ console.warn('WS err', err); }
  };
  ws.onclose = ()=> scheduleReconnect();
  ws.onerror = (e)=> { console.warn('WS error', e); if(ws) try{ ws.close(); } catch(e){} };
}
function scheduleReconnect(){ if(reconnectTimer) return; reconnectTimer = setTimeout(()=>{ reconnectTimer = null; connectWS(); }, 3000); }

/* ========== helpers ========== */
function ensureContactInList(tf17, name){
  let c = contacts.find(x => x.tf17 === tf17);
  if(!c){
    c = { tf17, name: name || formatTFShort(tf17), unread:0, lastMsg:'', lastTs: Date.now(), avatar:null, blocked:false };
    contacts.unshift(c); saveState(); renderContacts();
  }
  return c;
}

/* ========== UI wiring ========== */
sendBtnEl?.addEventListener('click', sendMessageFromModal);
chatTextEl?.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendMessageFromModal(); }});
document.getElementById('searchBtn')?.addEventListener('click', ()=> renderContacts(document.getElementById('searchInput').value));
document.getElementById('chatBack')?.addEventListener('click', ()=> { chatModalEl.style.display='none'; document.body.classList.remove('chat-open'); currentPartner=null; });

document.addEventListener('visibilitychange', ()=> {
  if(!document.hidden) {
    // sync unread convs
    contacts.filter(c => c.unread && c.tf17).forEach(c => { loadConversation(me.tf17, c.tf17).catch(()=>{}); });
  }
});

window.addEventListener('beforeunload', ()=> saveState());

/* ========== BOOT ========== */
renderContacts();
if(me.tf17){
  // load conv cache from localStorage
  try {
    const raw = localStorage.getItem('tfchat.conv.' + me.tf17);
    if(raw) conversationCache = JSON.parse(raw);
  } catch(e){}
  connectWS();
  // register SW
  ensureSWRegistered().then(()=>{ if(Notification.permission === 'granted' && !localStorage.getItem('tfchat.push.subscribed')) { subscribePushIfAllowed().catch(()=>{}); } });
} else {
  // no identity yet — show settings modal in your app flow
}
</script>
</body>
  </html>
